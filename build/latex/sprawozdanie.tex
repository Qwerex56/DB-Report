%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,polish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionspolish{\renewcommand{\contentsname}{Spis treści:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{sprawozdanie}
\date{01 lip 2024}
\release{1.0}
\author{Czubaty}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Wydanie}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Wstęp}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Wstep:wstep}}\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Wstep::doc}}
\sphinxAtStartPar
System zarządzania bazami danych (DBMS) jest bardzo ważnym elementem większości nowoczesnych aplikacji i usług. Dwa popularne systemy DBMS to SQLite i PostgreSQL. PostgreSQL jest potężnym systemem zarządzania relacyjnymi bazami danych obiektowymi oraz oferuje wiele zaawansowanych funkcji, takich jak transakcje z pełnym wsparciem dla ACID, subzapytania, wyzwalacze, widoki i przechowywane procedury. Jest również znany ze swojej skalowalności i niezawodności, co czyni go idealnym wyborem dla dużych i złożonych systemów baz danych. SQLite z kolei to lekka baza danych SQL, która jest znana z tego, że nie wymaga skomplikowanego sprzętu ani dużych zasobów systemowych do działania. Jest to idealne rozwiązanie dla aplikacji wbudowanych, systemów operacyjnych o ograniczonych zasobach oraz dla urządzeń mobilnych.

\sphinxstepscope


\chapter{Sprzęt dla bazy danych PostgreSQL}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:sprzet-dla-bazy-danych-postgresql}}\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1::doc}}
\sphinxAtStartPar
Wybór odpowiedniego sprzętu dla bazy danych PostgreSQL jest istotny aby  osiągnięć optymalną wydajność i niezawodność. Postegresql wymaga odpowiedniego sprzętu aby działał optymalnie. Tworząc bazę danych za pomocą PostegreSQL powinniśmy zaopatrzyć się  w sprzęt, który będzie odpowiedni pod PostegreSQL. Poniżej przedstawiono komponenty sprzętowe, które należy wziąć pod uwagę przy konfiguracji serwera dla PostgreSQL:


\section{Procesor (CPU):}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:procesor-cpu}}
\sphinxAtStartPar
Procesor jest sercem każdego serwera i ma ogromne znaczenie dla wydajności bazy danych. PostgreSQL może skorzystać z wielu rdzeni, więc zaleca się wybór procesora z wieloma rdzeniami i wysoką częstotliwością taktowania. Procesory z rodziny Intel Xeon lub AMD EPYC są często wybierane do zastosowań serwerowych ze względu na ich wydajność i niezawodność.


\section{Pamięć Operacyjna (RAM):}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:pamiec-operacyjna-ram}}
\sphinxAtStartPar
Pamięć RAM jest krytycznym zasobem dla PostgreSQL, ponieważ pozwala na przechowywanie aktywnych danych i indeksów w pamięci, co znacznie przyspiesza operacje odczytu i zapisu. Zaleca się posiadanie jak największej ilości pamięci RAM, która jest dostępna dla serwera, z minimalną rekomendacją wynoszącą 16 GB dla małych baz danych, aż do 256 GB lub więcej dla dużych wdrożeń baz danych.


\section{Przestrzeń Dyskowa (Storage):}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:przestrzen-dyskowa-storage}}
\sphinxAtStartPar
Wybór odpowiedniego typu i konfiguracji dysków jest istotny dla wydajności bazy danych. Dyski SSD (Solid State Drive) oferują znacznie lepszą wydajność niż tradycyjne dyski HDD, szczególnie w przypadku operacji o losowym dostępie, które są typowe dla baz danych. W przypadku dużych baz danych warto rozważyć zastosowanie rozwiązań RAID w celu zwiększenia niezawodności i wydajności.


\section{Sieć (Networking):}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:siec-networking}}
\sphinxAtStartPar
Szybka i stabilna sieć jest niezbędna do zapewnienia komunikacji między serwerem bazy danych a klientami oraz innymi serwerami w klastrze. Zaleca się użycie przynajmniej gigabitowych interfejsów sieciowych, a w przypadku większych wdrożeń rozważenie 10 gigabitowych lub szybszych rozwiązań.


\section{Zasilanie :}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:zasilanie}}
\sphinxAtStartPar
Nieprzerwane zasilanie jest bardzo istotne dla zapewnienia ciągłości działania serwera bazy danych. Zasilacz UPS może chronić sprzęt przed skutkami nagłych przerw w dostawie prądu i pozwala na bezpieczne wyłączenie serwera w przypadku dłuższej awarii zasilania.


\section{Chłodzenie (Cooling):}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_1:chlodzenie-cooling}}
\sphinxAtStartPar
Następną bardzo ważną sprawą przy sprzęcie dla baz danych jest adekwatne chłodzenie, aby zapewnić stabilną pracę komponentów serwera. Wysokie temperatury mogą skracać żywotność sprzętu i prowadzić do przestoju. Zaleca się stosowanie efektywnych systemów chłodzenia, szczególnie w serwerowniach z dużą liczbą urządzeń.

\sphinxAtStartPar
Baza danych PostegreSQL intensywnie korzysta z CPU, a zatem wybór procesora z wieloma rdzeniami i wysoką częstotliwości taktowania, będzie znacznie poprawiać wydajność tworzonej bazy danych. Oprócz tego warto zaopatrzyć się w odpowiednią ilość pamięci RAM, PostegreSQL przechowuje często używane dane w pamięci  ze względu na szybszy dostęp do tych danych, co oznacza, że wymaganiem tej bazy danych będzie więcej pamięci RAM.  Przechowywane dane znajdują się na dysku twardym, a więc czym więcej mamy pojemności dysku tym większą ilość danych możemy przechować. PostegreSQL nie jest wybredny co do rodzaju dysku, zarówno sprawdzi się dysk twardy HDD jak i SSD. Jednakże dyski SSD oferują znacznie szybsze czasy odczytu i zapisu w porównaniu do tradycyjnych dysków HDD, a to może przekładać się na szybsze zapytania i mniejsze opóźnienia.  Szybka i niezawodna sieć jest niezbędna dla baz danych PostgreSQL, szczególnie jeśli są one używane w środowiskach rozproszonych. Ważnym aspektem też jest nieprzerwane zasilanie dla utrzymania ciągłości działania bazy danych i zapobiegania utracie danych. PostgreSQL jest zaawansowanym systemem zarządzania relacyjnymi bazami danych, który wymaga odpowiedniego sprzętu do efektywnego działania. Wybór sprzętu powinien być dostosowany do specyficznych potrzeb i obciążenia, jakie przewiduje się dla bazy danych.

\sphinxstepscope


\chapter{SQLite}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_2:sqlite}}\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_2::doc}}
\sphinxAtStartPar
SQLite to lekki system zarządzania relacyjnymi bazami danych, który jest często używany w aplikacjach mobilnych i na komputerach stacjonarnych oraz jest szeroko stosowana w różnych aplikacjach, od urządzeń mobilnych po duże systemy. Ze względu na swoją prostotę i niewielkie wymagania sprzętowe, SQLite może działać na różnych platformach z minimalnymi wymaganiami sprzętowymi. SQLite jest znany z tego, że jest wyjątkowo lekki i może działać na szerokiej gamie sprzętu. Nie wymaga dedykowanego serwera ani skomplikowanej konfiguracji, co sprawia, że jest idealny dla aplikacji o ograniczonych zasobach sprzętowych. Poniżej przedstawiono podstawowe  informacje dotyczące SQLite:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Biblioteka SQLite może być zmniejszona do rozmiaru poniżej 300KiB, co czyni ją wyjątkowo kompaktową w porównaniu do innych systemów baz danych.

\item {} 
\sphinxAtStartPar
Ma minimalne Zapotrzebowanie na Pamięć:

\end{itemize}

\sphinxAtStartPar
SQLite może działać przy bardzo małym zużyciu pamięci stosu (stack) \sphinxhyphen{} około 4KiB oraz niewielkim zużyciu pamięci sterty (heap) \sphinxhyphen{} około 100KiB.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Może działać bez Serwera:

\end{itemize}

\sphinxAtStartPar
SQLite nie wymaga serwera do działania. Baza danych SQLite jest zintegrowana z aplikacją, która uzyskuje dostęp do bazy danych, a aplikacje wchodzą w interakcję bezpośrednio z plikami bazy danych przechowywanymi na dysku. SQLite jest zaprojektowany tak, aby być jak najbardziej kompatybilnym z innymi silnikami baz danych SQL. Dzięki temu, programiści doświadczeni w SQL powinni znaleźć się w  dialekcie  SQLite gdyż raczej będzie intuicyjny i naturalny. SQLite może pomijać niektóre mniej znane funkcje SQL, ale jego dialekt może zawierać pewne ulepszenia, których nie znajdziemy w niektórych dokumentach standardowych.

\sphinxAtStartPar
Wymagania sprzętowe dla SQLite są dość minimalne, oczywiście im lepszy sprzęt tym lepsze można osiągnąć wydajności bazy danych.

\sphinxAtStartPar
Urządzenia mobilne i wbudowane
Dla aplikacji mobilnych i wbudowanych, gdzie zasoby są ograniczone, SQLite jest doskonałym wyborem. Może działać na:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Smartfonach i tabletach z systemem Android lub iOS.

\item {} 
\sphinxAtStartPar
Systemach wbudowanych i IoT, takich jak Raspberry Pi czy Arduino.

\item {} 
\sphinxAtStartPar
Telewizorach Smart TV i systemach rozrywkowych w samochodach.

\item {} 
\sphinxAtStartPar
Komputery osobiste i serwery

\end{itemize}

\sphinxAtStartPar
SQLite może być również używany na komputerach osobistych i serwerach, gdzie zasoby nie są tak ograniczone. Może działać na:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Komputerach z systemem operacyjnym Windows, macOS lub Linux.

\item {} 
\sphinxAtStartPar
Serwerach, które mogą obsługiwać większe obciążenia i przechowywać większe bazy danych.

\end{itemize}

\sphinxAtStartPar
Chociaż SQLite może działać na różnorodnym sprzęcie, istnieją pewne optymalizacje, które można przeprowadzić, aby poprawić wydajność bazy danych. Warto jednak pomyśleć o doborze odpowiedniego sprzętu w zależności jak dużą bazę danych SQLite chce się stworzyć, warto pomyśleć o tym aby sprzęt miał odpowiednią ilość pamięci zarówno RAM jak i  przestrzeni dyskowej. Przy doborze sprzętu do tej bazy danych warto wziąć pod uwagę :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Pamięć RAM:

\end{itemize}

\sphinxAtStartPar
Im więcej pamięci RAM, tym lepiej, może to pomóc w przyspieszeniu operacji na bazie danych, ponieważ SQLite korzysta z pamięci do przechowywania tymczasowych tabel i buforowania danych.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Przestrzeń dyskowa:

\end{itemize}

\sphinxAtStartPar
SQLite przechowuje całą bazę danych w jednym pliku, więc ważne jest, aby mieć wystarczającą ilość przestrzeni dyskowej, szczególnie jeśli spodziewamy się wzrostu danych. Warto zwrócić uwagę też na rodzaj dysku, dysk SSD będzie lepiej się sprawował, dzięki temu, że osiąga szybsze wyniki odczytu i zapisu.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Procesor:

\end{itemize}

\sphinxAtStartPar
Szybszy procesor może poprawić czas odpowiedzi bazy danych, szczególnie przy skomplikowanych zapytaniach i dużych zbiorach danych.


\section{Przykładowe konfiguracje sprzętowe dla aplikacji mobilnych:}
\label{\detokenize{DB-Report/Bazy Danych Rozdzia_u0142 1/Pod_rozdzia_u0142_2:przykladowe-konfiguracje-sprzetowe-dla-aplikacji-mobilnych}}
\sphinxAtStartPar
Procesor: 4\sphinxhyphen{}rdzeniowy
RAM: 2 GB
Przestrzeń dyskowa: 32 GB
Dla aplikacji desktopowych:
Procesor: Intel Core i5 lub lepszy
RAM: 8 GB
Przestrzeń dyskowa: 256 GB SSD
Dla serwerów:
Procesor: Intel Xeon lub lepszy
RAM: 16 GB lub więcej
Przestrzeń dyskowa: 1 TB SSD lub więcej

\sphinxAtStartPar
SQLite jest niezwykle elastyczną bazą danych, która może działać na różnorodnym sprzęcie. Wybór odpowiedniego sprzętu zależy od wymagań aplikacji i oczekiwanej skali danych, ale zawsze warto zainwestować w lepszy sprzęt, aby zapewnić płynną pracę i szybką odpowiedź bazy danych.

\sphinxstepscope


\chapter{Lokalizacja i struktura katalogów}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial1:lokalizacja-i-struktura-katalogow}}\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial1::doc}}

\section{Lokalizacja:}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial1:lokalizacja}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} \begin{description}
\sphinxlineitem{Katalog danych:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/var/lib/postgresql/\textless{}wersja\textgreater{}/main}} na na systemach Debian/Ubuntu

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/var/lib/pgsql/\textless{}wersja\textgreater{}/data}} na systemach Red Hat/CentOS.

\item {} 
\sphinxAtStartPar
Zawiera wszystkie dane, pliki konfiguracyjne, logi i pliki kontrolne.

\end{itemize}

\end{description}

\item {} \begin{description}
\sphinxlineitem{Katalog Konfiguracyjny:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Pliki konfiguracyjne zwykle znajdują się w katalogu danych, choć zdarza się, że mogą znajdować się w innym katalogu np \sphinxcode{\sphinxupquote{/etc/postgresql/\textless{}wersja\textgreater{}/main}}

\end{itemize}

\end{description}

\item {} \begin{description}
\sphinxlineitem{Katalog logów:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Domyślnie \sphinxcode{\sphinxupquote{/var/log/postgresql}} na Debianie/Ubuntu oraz \sphinxcode{\sphinxupquote{/var/lib/pgsql/\textless{}wersja\textgreater{}/data/pg\_log}} na Red Har/CentOS

\item {} 
\sphinxAtStartPar
zawiera logi PostgreSQL

\end{itemize}

\end{description}

\end{enumerate}


\section{Struktura katalogów:}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial1:struktura-katalogow}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{base/}}: Zawiera dane użytkownika dla każdej bazy danych.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{global/}}: Przechowuje dane globalne, np. tabele systemowe.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_xlog/}} lub pg\_wal/ (od wersji 10): Zawiera dzienniki Write\sphinxhyphen{}Ahead Log (WAL).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_clog/}} lub pg\_xact/: Przechowuje dane dotyczące transakcji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_tblspc/}}: Linki symboliczne do tabel przestrzeni.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_multixact/}}: Dane dotyczące wielokrotnych transakcji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_subtrans/}}: Dane dotyczące podrzędnych transakcji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_stat/}}: Dane statystyczne.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_snapshots/}}: Przechowuje dane dotyczące snapshotów.

\end{itemize}

\sphinxstepscope


\chapter{Tabele \sphinxhyphen{} rozmiar, planowanie i monitorowanie}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial2:tabele-rozmiar-planowanie-i-monitorowanie}}\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial2::doc}}

\section{Rozmiar}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial2:rozmiar}}
\sphinxAtStartPar
Rozmiar tabel jest kluczowym aspektem zarządzania bazą danych, ponieważ bezpośrednio wpływa na wydajność systemu. Duże tabele mogą prowadzić do dłuższych czasów odpowiedzi na zapytania, zwiększonego zużycia pamięci oraz większych obciążeń wejścia/wyjścia.

\sphinxAtStartPar
\sphinxstylestrong{Monitorowanie rozmiaru tabel}
PostgreSQL dostarcza kilka narzędzi i zapytań SQL, które umożliwiają monitorowanie rozmiaru tabel:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar pojedynczej tabeli:}

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}nazwa\PYGZus{}tabeli\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{k}{size}\PYG{p}{;}%
}}

\sphinxAtStartPar
To zapytanie zwraca przyjazny dla użytkownika rozmiar całej tabeli, wliczając w to dane, indeksy oraz wszelkie towarzyszące pliki.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar wszystkich tabel w bazie danych:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{relname}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Table\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Size\PYGZdq{}}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}catalog}\PYG{p}{.}\PYG{n}{pg\PYGZus{}statio\PYGZus{}user\PYGZus{}tables}
\PYG{k}{ORDER}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To zapytanie zwraca listę wszystkich tabel w bazie danych wraz z ich rozmiarami, posortowaną według rozmiaru.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar indeksów tabeli:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{indexrelname}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Index\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{indexrelid}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Size\PYGZdq{}}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}user\PYGZus{}indexes}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{relname}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}nazwa\PYGZus{}tabeli\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To zapytanie zwraca listę indeksów dla określonej tabeli wraz z ich rozmiarami.


\section{Planowanie}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial2:planowanie}}
\sphinxAtStartPar
Planowanie tabel w PostgreSQL obejmuje kilka kluczowych aspektów, takich jak normalizacja, denormalizacja, indeksowanie oraz partycjonowanie.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Normalizacja} \sphinxhyphen{} Normalizacja to proces organizowania danych w bazie danych w taki sposób, aby zminimalizować redundancję i zapewnić integralność danych. Składa się z kilku form normalnych (NF), z których każda eliminuje różne rodzaje redundancji:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pierwsza forma normalna (1NF)}: Każda komórka tabeli zawiera pojedynczą wartość, a każde pole jest atomowe.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Druga forma normalna (2NF)}: Spełnia wymagania 1NF i zapewnia, że wszystkie kolumny niekluczowe są w pełni zależne od klucza głównego.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Trzecia forma normalna (3NF)}: Spełnia wymagania 2NF i zapewnia, że nie ma zależności przejściowych między kolumnami niekluczowymi.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Denormalizacja} \sphinxhyphen{} Denormalizacja to proces łączenia tabel, aby poprawić wydajność zapytań kosztem zwiększenia redundancji danych. Stosuje się ją wtedy, gdy zapytania często wymagają złączeń wielu tabel, co może wpływać na wydajność.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Indeksowanie} \sphinxhyphen{} Indeksy są kluczowe dla optymalizacji wydajności zapytań. Pozwalają one na szybsze wyszukiwanie, sortowanie i filtrowanie danych. W PostgreSQL dostępnych jest kilka typów indeksów:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{B\sphinxhyphen{}tree}: Najczęściej używany typ indeksu, odpowiedni dla większości operacji wyszukiwania.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Hash}: Szybszy dla operacji równościowych, ale mniej wszechstronny niż B\sphinxhyphen{}tree.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GIN (Generalized Inverted Index)}: Używany do indeksowania danych wielowartościowych, takich jak tabele JSONB i dokumenty pełnotekstowe.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GiST (Generalized Search Tree)}: Używany dla bardziej złożonych typów danych, takich jak geometria.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Przykład tworzenia indeksu B\sphinxhyphen{}tree:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{INDEX}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}nazwa\PYGZus{}kolumny}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{nazwa\PYGZus{}tabeli}\PYG{p}{(}\PYG{n}{nazwa\PYGZus{}kolumny}\PYG{p}{)}\PYG{p}{;}%
}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie} \sphinxhyphen{} Partycjonowanie polega na podzieleniu tabeli na mniejsze, bardziej zarządzalne części zwane partycjami. Może to znacznie poprawić wydajność zapytań, szczególnie w przypadku dużych tabel. PostgreSQL obsługuje kilka typów partycjonowania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie zakresowe (Range Partitioning)}: Dzieli dane na zakresy wartości.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie listy (List Partitioning)}: Dzieli dane na podstawie wartości z określonej listy.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie haszowe (Hash Partitioning)}: Dzieli dane na podstawie wartości haszowej.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Przykład tworzenia partycji zakresowej:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{p}{(}
\PYG{n}{order\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{n}{order\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{date}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{n}{customer\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{int}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{n}{amount}\PYG{+w}{ }\PYG{n+nb}{numeric}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{RANGE}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{order\PYGZus{}date}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}2022}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{orders}
\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2022\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2023\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}2023}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{orders}
\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2023\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Monitorowanie}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial2:monitorowanie}}
\sphinxAtStartPar
Dodatkowo możlive jest monitorowanie wydajności tabel za pomocą:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_stat\_user\_table:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{relname}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{seq\PYGZus{}scan}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{seq\PYGZus{}tup\PYGZus{}read}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}scan}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}tup\PYGZus{}fetch}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n\PYGZus{}tup\PYGZus{}ins}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n\PYGZus{}tup\PYGZus{}upd}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n\PYGZus{}tup\PYGZus{}del}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}user\PYGZus{}tables}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_stat\_activity:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{pid}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{usename}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{datname}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{state}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{query\PYGZus{}start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{query}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}activity}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Podstawowe parametry konfiguracyjne}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial3:podstawowe-parametry-konfiguracyjne}}\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial3::doc}}

\section{Plik postgresql.conf}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial3:plik-postgresql-conf}}
\sphinxAtStartPar
Plik \sphinxstyleemphasis{postgresql.conf} zawiera ustawienia dotyczące wydajności, logowania, sieci i wielu innych aspektów.

\sphinxAtStartPar
\sphinxstylestrong{Kluczowe ustawienia:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Słuchanie połączeń:}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{listen\PYGZus{}addresses} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{localhost}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Adresy IP, na których PostgreSQL będzie nasłuchiwać połączeń}
\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{5432}                     \PYG{c+c1}{\PYGZsh{} Port, na którym PostgreSQL będzie nasłuchiwać połączeń}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pamięć i wydajność:}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{shared\PYGZus{}buffers} \PYG{o}{=} \PYG{l+m+mi}{128}\PYG{n}{MB}           \PYG{c+c1}{\PYGZsh{} Ilość pamięci RAM przeznaczona na buforowanie danych}
\PYG{n}{work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{n}{MB}                   \PYG{c+c1}{\PYGZsh{} Ilość pamięci RAM na operacje sortowania i agregacji na użytkownika}
\PYG{n}{maintenance\PYGZus{}work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{64}\PYG{n}{MB}      \PYG{c+c1}{\PYGZsh{} Ilość pamięci RAM na operacje utrzymaniowe (np. VACUUM, CREATE INDEX)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Autovacuum:}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{autovacuum} \PYG{o}{=} \PYG{n}{on}                  \PYG{c+c1}{\PYGZsh{} Automatyczne czyszczenie i analiza tabel}
\PYG{n}{autovacuum\PYGZus{}naptime} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n+nb}{min}        \PYG{c+c1}{\PYGZsh{} Częstotliwość uruchamiania procesu autovacuum}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\section{Plik pg\_hba.conf}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial3:plik-pg-hba-conf}}
\sphinxAtStartPar
Plik \sphinxstylestrong{pg\_hba.conf} odpowiada za kontrolę dostępu do bazy danych PostgreSQL.

\sphinxAtStartPar
\sphinxstylestrong{Przykład konfiguracji:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} TYPE  DATABASE        USER            ADDRESS                 METHOD}

\PYG{c+c1}{\PYGZsh{} Zezwól lokalnym użytkownikom na połączenie}
\PYG{n}{local}   \PYG{n+nb}{all}             \PYG{n+nb}{all}                                     \PYG{n}{md5}

\PYG{c+c1}{\PYGZsh{} Zezwól zdalnym użytkownikom z sieci 192.168.1.0/24 na połączenie}
\PYG{n}{host}    \PYG{n+nb}{all}             \PYG{n+nb}{all}             \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.1}\PYG{l+m+mf}{.0}\PYG{o}{/}\PYG{l+m+mi}{24}          \PYG{n}{md5}
\end{sphinxVerbatim}


\section{Plik pg\_ident.conf}
\label{\detokenize{DB-Konfiguracja-bazy-danych/source/rozdzialy/rozdzial3:plik-pg-ident-conf}}
\sphinxAtStartPar
Plik \sphinxstylestrong{pg\_ident.conf} pozwala mapować systemowych użytkowników do użytkowników PostgreSQL.

\sphinxAtStartPar
\sphinxstylestrong{Przykład konfiguracji:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} MAPNAME       SYSTEM\PYGZhy{}USERNAME         PG\PYGZhy{}USERNAME}

\PYG{n}{mymap}           \PYG{n}{johndoe}                 \PYG{n}{john}
\PYG{n}{mymap}           \PYG{n}{janedoe}                 \PYG{n}{jane}
\end{sphinxVerbatim}

\sphinxAtStartPar
W pliku \sphinxstylestrong{pg\_hba.conf} można użyć tej mapy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{host}    \PYG{n+nb}{all}             \PYG{n+nb}{all}             \PYG{l+m+mf}{127.0}\PYG{l+m+mf}{.0}\PYG{l+m+mf}{.1}\PYG{o}{/}\PYG{l+m+mi}{32}            \PYG{n}{ident} \PYG{n+nb}{map}\PYG{o}{=}\PYG{n}{mymap}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Temat 3: Kontrola i Konserwacja}
\label{\detokenize{Sprawozdanie_bazy_p1/main:temat-3-kontrola-i-konserwacja}}\label{\detokenize{Sprawozdanie_bazy_p1/main::doc}}

\section{Konserwacja bazy danych}
\label{\detokenize{Sprawozdanie_bazy_p1/main:konserwacja-bazy-danych}}
\sphinxAtStartPar
Regularne utrzymywanie bazy danych w optymalnym stanie ma kluczowe znaczenie dla jej wydajności. Zapewnienie regularnej konserwacji jest niezbędne do utrzymania systemu na najwyższym poziomie działania. Zaleca się wprowadzenie harmonogramu konserwacji, który obejmie przynajmniej tygodniowe interwały.


\section{Kontrola danych}
\label{\detokenize{Sprawozdanie_bazy_p1/main:kontrola-danych}}
\sphinxAtStartPar
Kontrola danych to proces systematycznego zbierania, monitorowania i analizowania informacji w celu uzyskania wglądu, podejmowania świadomych decyzji oraz realizacji określonych celów. Obejmuje to stałe śledzenie i rejestrację istotnych punktów danych związanych z różnymi aspektami działalności firmy lub systemu, takimi jak zachowanie klientów, wskaźniki operacyjne czy trendy rynkowe. Surowe dane są przetwarzane w istotne spostrzeżenia, które mają wpływ na podejmowanie strategicznych decyzji oraz doskonalenie procesów.


\section{Znaczenie kontroli danych}
\label{\detokenize{Sprawozdanie_bazy_p1/main:znaczenie-kontroli-danych}}
\sphinxAtStartPar
Nie można przecenić znaczenia kontroli danych w dzisiejszym środowisku biznesowym. W miarę jak firmy operują w coraz bardziej złożonym i konkurencyjnym otoczeniu, wykorzystanie danych poprzez systematyczne monitorowanie przynosi liczne korzyści. Oto kilka kluczowych powodów, dla których zarządzanie danymi jest tak istotne:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Umożliwia podejmowanie świadomych decyzji.

\item {} 
\sphinxAtStartPar
Pomaga w ocenie wydajności.

\item {} 
\sphinxAtStartPar
Stanowi fundament ciągłego doskonalenia dzięki analizie danych.

\item {} 
\sphinxAtStartPar
Poprawia zrozumienie i postrzeganie klientów.

\end{itemize}


\section{Planowanie skutecznej kontroli danych}
\label{\detokenize{Sprawozdanie_bazy_p1/main:planowanie-skutecznej-kontroli-danych}}
\sphinxAtStartPar
1. \sphinxstylestrong{Określenie celów kontroli danych:}
Dokładne określenie celów zbierania danych, czyli jasne zdefiniowanie, co chcemy osiągnąć poprzez analizę gromadzonych informacji. Cele powinny być zgodne z celami biznesowymi i strategicznymi organizacji.

\sphinxAtStartPar
2. \sphinxstylestrong{Identyfikacja kluczowych wskaźników:}
Skoncentrowanie się na kluczowych wskaźnikach, które bezpośrednio odpowiadają ustalonym celom biznesowym. Kluczowe wskaźniki powinny być mierzalne i umożliwiać monitorowanie postępów w realizacji celów.

\sphinxAtStartPar
3. \sphinxstylestrong{Zidentyfikowanie źródeł danych:}
Pełna identyfikacja i udokumentowanie wszystkich potencjalnych źródeł danych, obejmujących zarówno wewnętrzne bazy danych, jak i interfejsy API stron trzecich, interakcje z klientami, analitykę witryn internetowych i inne istotne kanały.

\sphinxAtStartPar
4. \sphinxstylestrong{Zapewnienie jakości danych:}
Ustanowienie standardów i procedur dotyczących jakości danych w celu zapewnienia, że gromadzone dane są dokładne, kompletne i wiarygodne. Wdrożenie kontroli walidacyjnych pozwoli na wczesne wykrywanie ewentualnych błędów.

\sphinxAtStartPar
5. \sphinxstylestrong{Wybór narzędzi gromadzenia danych:}
Dobór odpowiednich narzędzi gromadzenia danych, które będą skutecznie wspierać proces kontroli danych, uwzględniając specyfikę analizowanych danych i potrzeby organizacji.

\sphinxAtStartPar
6. \sphinxstylestrong{Opracowanie strategii bezpieczeństwa danych:}
Wypracowanie solidnej strategii bezpieczeństwa danych, uwzględniającej zgodność z obowiązującymi przepisami o ochronie danych osobowych (np. RODO, HIPAA) oraz wdrożenie odpowiednich środków zapewniających ochronę wrażliwych informacji.

\sphinxAtStartPar
7. \sphinxstylestrong{Planowanie przechowywania i zarządzania danymi:}
Sporządzenie planu przechowywania i zarządzania danymi, uwzględniającego kwestie takie jak skalowalność, dostępność i zasady przechowywania danych, aby zapewnić ich bezpieczne i efektywne zarządzanie.

\sphinxAtStartPar
8. \sphinxstylestrong{Integracja danych:}
Integracja danych z różnych źródeł w celu stworzenia jednolitego i kompleksowego widoku, umożliwiającego bardziej wszechstronne analizy i wnioskowanie.

\sphinxAtStartPar
9. \sphinxstylestrong{Wdrożenie narzędzi do wizualizacji danych i raportowania:}
Implementacja narzędzi do wizualizacji danych i generowania raportów, które umożliwią zainteresowanym stronom łatwe zrozumienie danych oraz podejmowanie informowanych decyzji na ich podstawie.

\sphinxAtStartPar
10. \sphinxstylestrong{Automatyzacja gromadzenia danych:}
Jeśli to możliwe, automatyzacja procesu gromadzenia danych w celu zapewnienia spójności i terminowości, co przyczyni się do efektywniejszego wykorzystania zasobów oraz poprawy jakości analiz.

\sphinxAtStartPar
11. \sphinxstylestrong{Przeszkolenie członków zespołu:}
Zainwestuj w szkolenia dla członków zespołu, aby posiadali niezbędną wiedzę i umiejętności związane z gromadzeniem, analizowaniem, bezpieczeństwem i interpretacją danych. Regularne szkolenia pozwolą na ciągłe doskonalenie umiejętności zespołu i lepsze wykorzystanie potencjału danych.

\sphinxAtStartPar
12. \sphinxstylestrong{Wprowadzenie systemu ciągłej kontroli i konserwacji:}
Stwórz system ciągłej kontroli i konserwacji, który obejmuje regularne przeglądy jakości danych, aktualizacje procedur oraz dostosowanie się do zmian technologicznych. Zapewnienie elastyczności i adaptacyjności systemu pozwoli na utrzymanie wydajności i celowości działań w długim okresie czasu.

\sphinxAtStartPar
13. \sphinxstylestrong{Implementacja pętli informacji zwrotnej:}
Wprowadź mechanizmy pętli informacji zwrotnej, które umożliwią ciągłe doskonalenie procesów kontrolnych. Zachęcaj użytkowników do przekazywania opinii na temat jakości i użyteczności danych oraz wykorzystaj te informacje do doskonalenia procedur i procesów kontroli.

\sphinxAtStartPar
14. \sphinxstylestrong{Projektowanie skalowalnego systemu kontroli danych:}
Zaprojektuj system kontroli danych w sposób skalowalny, aby mógł elastycznie rosnąć wraz z ilością danych i ich złożonością. Uwzględnij przyszłe potrzeby i zmiany technologiczne, aby infrastruktura była w stanie sprostać rosnącym wymaganiom organizacji.

\sphinxAtStartPar
15. \sphinxstylestrong{Przeprowadzanie regularnych audytów:}
Regularnie przeprowadzaj audyty, aby upewnić się, że procesy kontroli danych są zgodne z pierwotnymi celami i spełniają wymogi prawne. Audyty pozwalają na identyfikację obszarów wymagających ulepszeń oraz zapewnienie ciągłej zgodności z najnowszymi standardami i regulacjami.


\section{Autorzy}
\label{\detokenize{Sprawozdanie_bazy_p1/main:autorzy}}
\sphinxAtStartPar
Michał Pawlica
Wiktor Nowicki

\sphinxstepscope


\chapter{Monitorowanie i Diagnostyka}
\label{\detokenize{MonitDiagnostyka/cos/Monitorowanie_i_Diagnostyka:monitorowanie-i-diagnostyka}}\label{\detokenize{MonitDiagnostyka/cos/Monitorowanie_i_Diagnostyka::doc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Sesje i użytkownicy}: Monitorowanie sesji i użytkowników w administracji baz danych jest kluczowym elementem. Pozwala to na śledzenie aktywności użytkowników, zarządzanie zasobami oraz wykrywanie potencjalnych problemów.
\begin{quote}

\sphinxAtStartPar
1.1 \sphinxstylestrong{Szczegółowe monitorowanie aktywności użytkowników}: Administratorzy baz danych mogą śledzić, które zapytania są wykonywane przez użytkowników, jak długo trwają te zapytania i jakie są ich wyniki. Można to zrobić za pomocą narzędzi takich jak SQL Profiler (w przypadku SQL Server) lub AWR (w przypadku Oracle). Te narzędzia mogą dostarczyć szczegółowych informacji na temat zapytań, takich jak czas wykonania, zużycie procesora, ilość odczytów i zapisów na dysk, a nawet plan wykonania zapytania. Dodatkowo, administratorzy mogą monitorować aktywność na poziomie sesji, taką jak liczba otwartych transakcji, czas trwania sesji, używane zasoby i inne.

\sphinxAtStartPar
1.2 \sphinxstylestrong{Zarządzanie zasobami na poziomie sesji}: Administratorzy baz danych mogą używać narzędzi do monitorowania zasobów, takich jak Performance Monitor (w przypadku Windows) lub top (w przypadku Linux), aby zobaczyć, które procesy zużywają najwięcej zasobów. Można również skonfigurować limity zasobów dla poszczególnych użytkowników lub sesji, aby zapobiec monopolizowaniu zasobów przez pojedyncze sesje. Administratorzy mogą również monitorować użycie zasobów na poziomie sesji, takie jak zużycie procesora, pamięci, dysku i sieci, co może pomóc w identyfikowaniu i rozwiązywaniu problemów z wydajnością.

\sphinxAtStartPar
1.3 \sphinxstylestrong{Wykrywanie problemów na poziomie sesji}: Administratorzy baz danych mogą używać narzędzi do monitorowania bazy danych, aby wykrywać problemy takie jak blokady, długotrwałe transakcje, czy błędy w zapytaniach. Na przykład, SQL Server oferuje narzędzie o nazwie Activity Monitor, które pokazuje informacje o blokadach, a Oracle oferuje narzędzie o nazwie Automatic Database Diagnostic Monitor (ADDM), które automatycznie wykrywa i diagnozuje problemy z wydajnością. Administratorzy mogą również monitorować logi błędów i ostrzeżeń generowane przez DBMS, co może pomóc w identyfikowaniu i rozwiązywaniu problemów.

\sphinxAtStartPar
1.4 \sphinxstylestrong{Bezpieczeństwo}: Monitorowanie sesji i użytkowników jest również ważne z punktu widzenia bezpieczeństwa. Administratorzy mogą śledzić, kto loguje się do systemu, kiedy to robią i co robią. Można to zrobić za pomocą logów audytu bazy danych. W przypadku podejrzanej aktywności, takiej jak próby logowania poza normalnymi godzinami pracy, administratorzy mogą podjąć odpowiednie działania, takie jak zmiana hasła użytkownika lub zablokowanie konta.

\sphinxAtStartPar
1.5 \sphinxstylestrong{Zgodność}: Monitorowanie sesji i użytkowników jest również ważne z punktu widzenia zgodności z przepisami. Administratorzy mogą używać narzędzi do audytu, takich jak SQL Server Audit lub Oracle Database Audit, aby zobaczyć, kto miał dostęp do jakich danych i kiedy. Te informacje mogą być użyte do udowodnienia zgodności z przepisami dotyczącymi ochrony danych, takimi jak RODO.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Śledzenie dostępu użytkowników do poszczególnych tabel}: Śledzenie dostępu użytkowników do poszczególnych tabel jest istotnym elementem monitorowania i diagnostyki bazy danych. Pozwala to na zrozumienie, jak użytkownicy korzystają z danych, a także na wykrywanie potencjalnych problemów lub podejrzanej aktywności.
\begin{quote}

\sphinxAtStartPar
2.1 \sphinxstylestrong{Zrozumienie użycia danych}: Administratorzy baz danych mogą używać narzędzi do monitorowania dostępu do tabel, aby zrozumieć, jakie tabele są najczęściej odwiedzane i jakie operacje są najczęściej wykonywane. Na przykład, mogą używać narzędzi do monitorowania wydajności, takich jak SQL Server Profiler lub Oracle Enterprise Manager, aby zobaczyć, które zapytania są najczęściej wykonywane i jak długo trwają. Mogą również używać narzędzi do analizy logów, takich jak Log Miner w Oracle, aby zobaczyć, kiedy i przez kogo dane tabele były modyfikowane. Te narzędzia mogą dostarczyć szczegółowych informacji na temat zapytań, takich jak czas wykonania, zużycie procesora, ilość odczytów i zapisów na dysk, a nawet plan wykonania zapytania.

\sphinxAtStartPar
2.2 \sphinxstylestrong{Wykrywanie problemów}: Jeśli użytkownik nagle zaczyna wykonywać dużą liczbę zapytań do określonej tabeli, może to być oznaką problemu. Na przykład, może to oznaczać, że zapytanie jest niewłaściwie skonstruowane lub że aplikacja jest zapętlona. Administratorzy mogą używać narzędzi do monitorowania wydajności, aby zidentyfikować te problemy i podjąć odpowiednie działania. Narzędzia te mogą dostarczyć szczegółowych informacji na temat zapytań, takich jak czas wykonania, zużycie procesora, ilość odczytów i zapisów na dysk, a nawet plan wykonania zapytania.

\sphinxAtStartPar
2.3 \sphinxstylestrong{Bezpieczeństwo i zgodność}: Śledzenie dostępu do tabel jest również ważne z punktu widzenia bezpieczeństwa. Administratorzy mogą używać narzędzi do audytu, takich jak SQL Server Audit lub Oracle Database Audit, aby zobaczyć, kto miał dostęp do jakich danych i kiedy. Mogą również skonfigurować alerty, które powiadamiają ich o podejrzanej aktywności, takiej jak próby dostępu do danych poza normalnymi godzinami pracy. Wszystko to pomaga w utrzymaniu zgodności z przepisami dotyczącymi ochrony danych, takimi jak RODO.

\sphinxAtStartPar
2.4 \sphinxstylestrong{Analiza trendów}: Administratorzy mogą analizować dane z monitorowania dostępu do tabel, aby zidentyfikować trendy w użyciu danych. Na przykład, mogą zauważyć, że pewne tabele są odwiedzane częściej w określonych godzinach dnia lub dniach tygodnia. Te informacje mogą pomóc w planowaniu przyszłych potrzeb zasobów i optymalizacji systemu.

\sphinxAtStartPar
2.5 \sphinxstylestrong{Optymalizacja wydajności}: Na podstawie informacji uzyskanych z monitorowania dostępu do tabel, administratorzy mogą podjąć działania w celu optymalizacji wydajności systemu. Na przykład, jeśli zauważą, że pewne zapytania są wykonywane bardzo często, mogą zdecydować się na optymalizację tych zapytań, na przykład poprzez dodanie indeksów do odpowiednich tabel.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Błędy dziennika i raporty}: Monitorowanie błędów dziennika i raportów jest kluczowym elementem zarządzania bazą danych. Pozwala to na szybkie wykrywanie i rozwiązywanie problemów, zanim wpłyną one na działanie systemu.
\begin{quote}

\sphinxAtStartPar
3.1 \sphinxstylestrong{Dzienniki błędów}: Dzienniki błędów są zapisywane przez system zarządzania bazą danych (DBMS) i zawierają informacje o wszelkich błędach, które wystąpiły podczas działania systemu. Mogą zawierać informacje takie jak kod błędu, czas wystąpienia błędu, zapytanie, które spowodowało błąd, i inne szczegóły, które mogą pomóc w diagnozowaniu problemu. Administratorzy baz danych powinni regularnie sprawdzać dzienniki błędów i reagować na wszelkie poważne błędy. Dzienniki błędów mogą również pomóc w identyfikowaniu wzorców błędów, co może pomóc w przyszłych działaniach prewencyjnych.

\sphinxAtStartPar
3.2 \sphinxstylestrong{Raporty}: Raporty są generowane przez narzędzia monitorujące i mogą zawierać informacje na temat wydajności systemu, użycia zasobów, aktywności użytkowników i innych aspektów działania bazy danych. Raporty mogą być generowane na żądanie lub automatycznie w określonych interwałach czasu. Mogą być również konfigurowane do wysyłania powiadomień e\sphinxhyphen{}mail lub SMS w przypadku wykrycia określonych warunków, takich jak przekroczenie progu użycia zasobów. Raporty mogą pomóc w identyfikowaniu obszarów, które wymagają uwagi, i mogą dostarczyć cennych informacji do analizy trendów i planowania przyszłości.

\sphinxAtStartPar
3.3 \sphinxstylestrong{Analiza i diagnoza}: Dzienniki błędów i raporty są kluczowymi narzędziami do analizy i diagnozy problemów z bazą danych. Na przykład, jeśli system jest wolny, administrator może sprawdzić raporty wydajności, aby zobaczyć, które zapytania są najwolniejsze, a następnie sprawdzić dzienniki błędów, aby zobaczyć, czy te zapytania powodują jakiekolwiek błędy. Na podstawie tych informacji, administrator może podjąć działania w celu optymalizacji zapytań lub zwiększenia dostępnych zasobów.

\sphinxAtStartPar
3.4 \sphinxstylestrong{Planowanie i optymalizacja}: Dzienniki błędów i raporty mogą również pomóc w planowaniu przyszłych potrzeb zasobów i optymalizacji systemu. Na przykład, jeśli raporty pokazują, że użycie procesora jest regularnie wysokie, administrator może zdecydować o zwiększeniu liczby rdzeni procesora dostępnych dla systemu. Podobnie, jeśli dzienniki błędów pokazują, że często występują błędy związane z brakiem pamięci, administrator może zdecydować o zwiększeniu dostępnej pamięci.

\sphinxAtStartPar
3.5 \sphinxstylestrong{Zabezpieczenia i audyt}: Monitorowanie błędów dziennika i raportów jest również ważne z punktu widzenia bezpieczeństwa. Administratorzy mogą używać narzędzi do audytu, takich jak SQL Server Audit lub Oracle Database Audit, aby zobaczyć, kto miał dostęp do jakich danych i kiedy. Mogą również skonfigurować alerty, które powiadamiają ich o podejrzanej aktywności, takiej jak próby dostępu do danych poza normalnymi godzinami pracy. Wszystko to pomaga w utrzymaniu zgodności z przepisami dotyczącymi ochrony danych, takimi jak RODO.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Monitorowanie na poziomie systemu operacyjnego}: Monitorowanie na poziomie systemu operacyjnego jest kluczowym elementem zarządzania bazą danych. Pozwala to na śledzenie użycia zasobów systemowych, takich jak procesor, pamięć, dysk twardy i sieć, co może pomóc w wykrywaniu i rozwiązywaniu problemów z wydajnością.
\begin{quote}

\sphinxAtStartPar
4.1 \sphinxstylestrong{iostat} (\sphinxstyleemphasis{Linux}): Narzędzie iostat jest częścią pakietu sysstat w systemach Linux. Umożliwia monitorowanie statystyk wejścia/wyjścia (I/O) dla urządzeń I/O i partycji. Może pomóc w identyfikowaniu problemów z dyskiem twardym, takich jak nadmierne użycie dysku lub długie czasy oczekiwania na I/O. iostat dostarcza szczegółowych informacji na temat obciążenia dysku, takich jak prędkość transferu danych, ilość operacji wejścia/wyjścia na sekundę, średni czas oczekiwania na operację I/O i inne.

\sphinxAtStartPar
4.2 \sphinxstylestrong{htop} (\sphinxstyleemphasis{Linux}): htop to zaawansowany menedżer zadań dla systemów Linux. Wyświetla listę aktualnie działających procesów i umożliwia sortowanie ich według różnych kryteriów, takich jak użycie procesora, pamięci, czasu procesora i innych. Pozwala to na szybkie zidentyfikowanie procesów, które zużywają najwięcej zasobów. htop oferuje również funkcje takie jak wyświetlanie drzewa procesów, wyszukiwanie procesów, filtrowanie procesów według użytkownika i inne.

\sphinxAtStartPar
4.3 \sphinxstylestrong{vmstat} (\sphinxstyleemphasis{Linux}): vmstat to narzędzie, które dostarcza informacji o procesach, pamięci, stronach, blokach wejścia/wyjścia, aktywności procesora i dysku. Jest to przydatne narzędzie do monitorowania wydajności systemu. vmstat dostarcza szczegółowych informacji na temat użycia procesora, pamięci, dysku i sieci, co może pomóc w identyfikowaniu wąskich gardeł i optymalizacji wydajności systemu.

\sphinxAtStartPar
4.4 \sphinxstylestrong{Menedżer zadań} (\sphinxstyleemphasis{Windows}): Menedżer zadań w systemie Windows umożliwia monitorowanie użycia procesora, pamięci, dysku i sieci przez poszczególne procesy i usługi. Może pomóc w identyfikowaniu aplikacji lub procesów, które zużywają nadmierną ilość zasobów. Menedżer zadań oferuje również funkcje takie jak zakończanie procesów, zmiana priorytetu procesów, monitorowanie użycia sieci i inne.

\sphinxAtStartPar
4.5 \sphinxstylestrong{Monitor systemu} (\sphinxstyleemphasis{Windows}): Monitor systemu w systemie Windows jest zaawansowanym narzędziem do monitorowania wydajności systemu. Umożliwia śledzenie wielu różnych wskaźników wydajności, takich jak użycie procesora, pamięci, dysku i sieci, a także statystyki dotyczące systemu plików, bazy danych i innych komponentów systemu. Monitor systemu umożliwia tworzenie niestandardowych zestawów wskaźników wydajności, zapisywanie danych wydajności do plików logów i generowanie raportów wydajności.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Monitorowanie serwera} (\sphinxstyleemphasis{np. Nagios, Grafana}): Monitorowanie serwera jest kluczowym elementem zarządzania infrastrukturą IT. Pozwala na śledzenie stanu serwerów i usług, wykrywanie problemów i analizę wydajności.
\begin{quote}

\sphinxAtStartPar
5.1 \sphinxstylestrong{Nagios}: Nagios to potężne narzędzie do monitorowania systemów, sieci i infrastruktury. Pozwala na śledzenie stanu serwerów, usług sieciowych, urządzeń sieciowych i innych zasobów IT.

\sphinxAtStartPar
Nagios oferuje funkcje takie jak:
\begin{quote}

\sphinxAtStartPar
5.1.1 \sphinxstylestrong{Monitorowanie zasobów}: Nagios może monitorować zużycie procesora, pamięci, dysku, obciążenie sieci i inne metryki zasobów na serwerach i innych urządzeniach. Może dostarczyć szczegółowych informacji na temat użycia zasobów, co może pomóc w identyfikowaniu wąskich gardeł i optymalizacji wydajności systemu.

\sphinxAtStartPar
5.1.2 \sphinxstylestrong{Wykrywanie problemów}: Nagios może automatycznie wykrywać problemy, takie jak awarie serwerów, przeciążenie sieci, brak miejsca na dysku i inne problemy. Może wysyłać powiadomienia e\sphinxhyphen{}mail, SMS lub inne, gdy wykryje problem. Może również skonfigurować alerty, które powiadamiają administratora o podejrzanej aktywności, takiej jak niezwykle wysokie zużycie zasobów.

\sphinxAtStartPar
5.1.3 \sphinxstylestrong{Raporty i analizy}: Nagios generuje szczegółowe raporty o stanie infrastruktury IT, które mogą pomóc w analizie wydajności, planowaniu przyszłych potrzeb zasobów i identyfikowaniu obszarów, które wymagają uwagi. Raporty mogą zawierać informacje takie jak historia użycia zasobów, statystyki wydajności, logi błędów i inne.
\end{quote}

\sphinxAtStartPar
5.2 \sphinxstylestrong{Grafana}: Grafana to otwarte oprogramowanie do wizualizacji danych, które jest często używane do monitorowania wydajności serwerów i usług.

\sphinxAtStartPar
Grafana oferuje funkcje takie jak:
\begin{quote}

\sphinxAtStartPar
5.2.1 \sphinxstylestrong{Wizualizacja danych}: Grafana umożliwia tworzenie interaktywnych wykresów, histogramów, map ciepła i innych wizualizacji danych. Można go używać do wizualizacji metryk takich jak zużycie procesora, pamięci, obciążenie sieci, liczba użytkowników online i inne. Grafana oferuje szeroki zakres opcji personalizacji, co pozwala na tworzenie wysoce szczegółowych i informatywnych wykresów.

\sphinxAtStartPar
5.2.2 \sphinxstylestrong{Integracja z różnymi źródłami danych}: Grafana może pobierać dane z wielu różnych źródeł, takich jak bazy danych SQL, systemy monitorowania jak Prometheus czy Graphite, pliki CSV i inne. Dzięki temu jest to bardzo elastyczne narzędzie, które można dostosować do różnych środowisk i potrzeb.

\sphinxAtStartPar
5.2.3 \sphinxstylestrong{Alerty}: Grafana umożliwia konfigurację alertów, które mogą wysyłać powiadomienia, gdy określone warunki są spełnione. Na przykład, można skonfigurować alert, który wysyła powiadomienie, gdy zużycie procesora na serwerze przekracza określony próg. Alerty mogą być wysyłane za pośrednictwem różnych kanałów, takich jak e\sphinxhyphen{}mail, Slack, PagerDuty i inne.
\end{quote}
\end{quote}

\end{enumerate}

\sphinxstepscope

\sphinxAtStartPar
\sphinxurl{https://github.com/Qwerex56/DB-Report} \sphinxhyphen{} Link do projektu aplikacji laboratoryjnej


\chapter{Kontrola i buforowanie połączeń}
\label{\detokenize{rozdzialy/rozdzial1:kontrola-i-buforowanie-polaczen}}\label{\detokenize{rozdzialy/rozdzial1::doc}}
\sphinxAtStartPar
Kontrola i buforowanie połączeń z bazą danych to kluczowe aspekty zarządzania bazami danych, które mają na celu optymalizację wydajności i zapewnienie niezawodności.


\section{Kontrola połączeń z bazą danych:}
\label{\detokenize{rozdzialy/rozdzial1:kontrola-polaczen-z-baza-danych}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Zarządzanie pulą połączeń: Technika ta pozwala aplikacjom na utrzymanie puli aktywnych połączeń z bazą danych, które są wielokrotnie używane. Poprzez efektywne zarządzanie pulą połączeń, aplikacje mogą minimalizować koszty związane z nawiązywaniem nowych połączeń, co przyczynia się do zwiększenia wydajności i efektywności systemu.

\item {} 
\sphinxAtStartPar
Monitorowanie wydajności połączenia: Proces ten obejmuje śledzenie metryk związanych z połączeniem z bazą danych, takich jak czas odpowiedzi, błędy połączenia, ilość przesyłanych danych itp. Regularne monitorowanie tych metryk umożliwia szybkie wykrywanie problemów, co pozwala na ich natychmiastowe rozwiązanie i poprawę ogólnej wydajności systemu.

\item {} 
\sphinxAtStartPar
Zarządzanie transakcjami: Kontrola nad transakcjami obejmuje precyzyjne określenie, kiedy i w jaki sposób transakcje są przetwarzane w bazie danych. Poprzez skuteczne zarządzanie transakcjami, można zapewnić spójność danych oraz uniknąć konfliktów. Przykładowo, dbając o to, aby operacje w ramach jednej transakcji były wykonywane jako jedna, niepodzielna jednostka pracy, zapewniamy integralność danych.

\end{itemize}


\section{Buforowanie połączeń z bazą danych:}
\label{\detokenize{rozdzialy/rozdzial1:buforowanie-polaczen-z-baza-danych}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Buforowanie zapytań: Technika ta polega na przechowywaniu wyników często używanych zapytań w pamięci podręcznej. Dzięki temu, gdy aplikacja ponownie potrzebuje wyników tego samego zapytania, może je szybko pobrać z pamięci podręcznej, co znacząco przyspiesza czas odpowiedzi i zmniejsza obciążenie bazy danych.

\item {} 
\sphinxAtStartPar
Buforowanie wyników: Podobnie jak buforowanie zapytań, buforowanie wyników polega na przechowywaniu wyników kosztownych zapytań w pamięci podręcznej na przyszłe użycie. To pozwala uniknąć ponownego przetwarzania zapytań, które wymagają skomplikowanych obliczeń lub dostępu do wielu tabel, co przyczynia się do poprawy wydajności systemu.

\item {} 
\sphinxAtStartPar
Inwalidacja bufora: Proces inwalidacji bufora polega na usuwaniu danych z pamięci podręcznej, gdy stają się przestarzałe lub nieaktualne. Jest to istotny aspekt zarządzania pamięcią podręczną, który zapewnia, że przechowywane dane są zawsze aktualne. Mechanizmy inwalidacji bufora mogą być zautomatyzowane (np. usuwanie danych po określonym czasie) lub sterowane manualnie przez aplikację

\end{itemize}

\sphinxstepscope


\chapter{Indeks i klaster}
\label{\detokenize{rozdzialy/rozdzial2:indeks-i-klaster}}\label{\detokenize{rozdzialy/rozdzial2::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Indeks w bazie danych to struktura danych, która poprawia szybkość operacji na tabeli poprzez działanie podobne do indeksu w książce. Zamiast przeszukiwać całą tabelę, aby znaleźć konkretną informację, możemy skorzystać z indeksu, który bezpośrednio wskazuje, gdzie ta informacja się znajduje. W bazie danych indeksy są używane do szybkiego wyszukiwania i dostępu do danych w tabeli poprzez tworzenie indeksów na kolumnach tabeli.

\item {} 
\sphinxAtStartPar
Klaster w bazie danych to technika przechowywania danych dwóch lub więcej powiązanych tabel w tym samym obszarze dysku. Tabele są powiązane za pomocą kluczy obcych, co umożliwia szybki dostęp do powiązanych danych. Klasterowanie może znacznie poprawić wydajność baz danych, ponieważ dane powiązane są przechowywane blisko siebie na dysku, co redukuje czas potrzebny na przeszukiwanie i dostęp do danych.

\end{itemize}

\sphinxstepscope


\chapter{Wydajność}
\label{\detokenize{rozdzialy/rozdzial3:wydajnosc}}\label{\detokenize{rozdzialy/rozdzial3::doc}}
\sphinxAtStartPar
Wydajność bazy danych to kluczowy aspekt zarządzania danymi, który ma bezpośredni wpływ na funkcjonowanie i sukces organizacji. W dobie cyfryzacji i rosnącej zależności od danych, zarządzanie wydajnością baz danych stało się nieodzownym elementem strategii IT. W tym podpunkcie opiszemy sześć kluczowych aspektów wydajności baz danych: czasy odpowiedzi, przepustowość, współbieżność, wykorzystanie zasobów, zapytania N+1 i błędy bazy danych.
Parametry wydajności baz danych są podstawowymi wskaźnikami zdrowia systemu baz danych. Monitorowanie tych parametrów i proaktywne zarządzanie nimi jest kluczowe dla utrzymania zdrowia i wydajności bazy danych. Niewidoczne lub niemonitorowane problemy mogą prowadzić do poważnych zakłóceń, takich jak spadek wydajności, potencjalna utrata danych, a nawet awaria systemu, dlatego parametry wydajności nie mogą być ignorowane.


\section{1. Czasy odpowiedzi}
\label{\detokenize{rozdzialy/rozdzial3:czasy-odpowiedzi}}\begin{description}
\sphinxlineitem{Czasy odpowiedzi bazy danych są kluczowym elementem w środowiskach, gdzie szybkie decyzje mają kluczowe znaczenie, jak w usługach finansowych czy sytuacjach awaryjnych. Kilka czynników wpływa na czas odpowiedzi:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Architektura bazy danych: Fizyczny i logiczny projekt bazy danych, w tym partycjonowanie, indeksowanie i przechowywanie danych, mają istotny wpływ. Odpowiednie partycjonowanie i indeksowanie danych może skrócić czas wyszukiwania, a korzystanie z baz danych w pamięci może znacząco przyspieszyć operacje poprzez uniknięcie dostępu do dysku.

\item {} 
\sphinxAtStartPar
Topologia i kondycja sieci: W rozproszonych bazach danych, konfiguracja sieci, opóźnienia, przepustowość i utrata pakietów mają znaczący wpływ na czas pobierania i zwracania danych. Optymalizacja sieci i kompresja danych mogą pomóc zminimalizować opóźnienia.

\item {} 
\sphinxAtStartPar
Równoczesny dostęp i równoważenie obciążenia: Techniki takie jak łączenie połączeń, równoważenie obciążenia i replikacja odczytu mogą równomiernie rozłożyć obciążenie, co przekłada się na optymalne czasy odpowiedzi nawet przy dużym ruchu.

\end{itemize}

\end{description}

\sphinxAtStartPar
Wydajne czasy odpowiedzi są kluczowe dla operacyjnej wydajności, zadowolenia klientów i wyników finansowych firm. Są one wskaźnikiem kondycji systemu baz danych, wpływającym na przepustowość i skalowalność infrastruktury IT. W sektorach zwiększającej się ilości danych utrzymanie szybkich czasów odpowiedzi może stanowić przewagę konkurencyjną.


\section{2. Przepustowość}
\label{\detokenize{rozdzialy/rozdzial3:przepustowosc}}\begin{description}
\sphinxlineitem{Przepustowość bazy danych jest kluczowym wskaźnikiem efektywności systemu w obsłudze danych w określonym czasie. Wysoka przepustowość oznacza zdolność bazy danych do obsłużenia większej liczby żądań lub operacji w sposób szybki i wydajny. Wpływ na przepustowość mają różne czynniki, takie jak:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Współbieżność: Mechanizmy zarządzania transakcjami i blokowania odgrywają istotną rolę w zapewnieniu integralności danych i zwiększeniu wydajności. Efektywne zarządzanie transakcjami pozwala wielu użytkownikom na jednoczesne operacje bez zakłóceń, co jest istotne w środowiskach o dużym obciążeniu, jak podczas wyprzedaży online. Więcej o współbieżności w kolejnym punkcie.

\item {} 
\sphinxAtStartPar
Bazy danych NoSQL: Systemy NoSQL korzystają z podejścia opartego na ewentualnej spójności, co pozwala na szybsze operacje zapisu poprzez unikanie oczekiwania na zaktualizowanie wszystkich kopii danych we wszystkich węzłach.

\item {} 
\sphinxAtStartPar
Dystrybucja danych: Techniki takie jak sharding w NoSQL lub partycjonowanie w bazach SQL pozwalają na podział danych na wiele serwerów lub partycji, co zmniejsza obciążenie poszczególnych elementów systemu i poprawia ogólną zdolność do obsługi dużych ilości operacji.

\end{itemize}

\end{description}

\sphinxAtStartPar
Warto zauważyć, że odpowiednie zarządzanie współbieżnością, wybór odpowiedniego typu bazy danych oraz efektywna dystrybucja danych mają kluczowe znaczenie dla osiągnięcia wysokiej przepustowości bazy danych.


\section{3. Współbieżność}
\label{\detokenize{rozdzialy/rozdzial3:wspolbieznosc}}\begin{description}
\sphinxlineitem{Współbieżność w bazach danych odnosi się do zdolności systemu do obsługi wielu operacji jednocześnie, co jest kluczowe w środowiskach, gdzie wiele użytkowników lub aplikacji korzysta z bazy danych równocześnie. Parametry wydajności baz danych, takie jak transakcje na sekundę (TPS) i zapytania na sekundę (QPS), mierzą współbieżność bazy danych poprzez liczbę operacji, jakie może obsłużyć w jednostce czasu. Czynniki wpływające pozytywnie na współbieżność to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Mechanizmy blokujące: Efektywne zarządzanie blokadami umożliwia uniknięcie rywalizacji między transakcjami, co przyczynia się do płynniejszego działania bazy danych.

\item {} 
\sphinxAtStartPar
Poziomy izolacji transakcji: Wybór odpowiedniego poziomu izolacji transakcji ma wpływ na dokładność danych i współbieżność. Wyższe poziomy izolacji zapewniają większą dokładność, ale mogą ograniczać współbieżność poprzez blokowanie transakcji.

\item {} 
\sphinxAtStartPar
Architektura bazy danych: Ogólny projekt bazy danych, zwłaszcza w przypadku rozproszonych baz danych, może wpłynąć na zdolność systemu do obsługi wielu równoczesnych żądań poprzez rozłożenie obciążenia na wiele węzłów.

\end{itemize}

\sphinxlineitem{Wyzwania dla współbieżności obejmują:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Zakleszczenia (Deadlocki): Sytuacje, w których transakcje blokują się nawzajem, uniemożliwiając kontynuację, co może spowolnić bazę danych.

\item {} 
\sphinxAtStartPar
Głód zasobów: Kiedy procesy zużywają zbyt dużo zasobów, ograniczając dostępność dla innych procesów i zmniejszając współbieżność.

\item {} 
\sphinxAtStartPar
Hotspoty danych: Częsty dostęp do tych samych punktów danych może tworzyć wąskie gardła, ograniczając współbieżność poprzez tworzenie kolejek dostępu do zasobów.

\end{itemize}

\end{description}


\section{4. Wykorzystanie zasobów (CPU, pamięć, I/O dysku)}
\label{\detokenize{rozdzialy/rozdzial3:wykorzystanie-zasobow-cpu-pamiec-i-o-dysku}}\begin{description}
\sphinxlineitem{Wykorzystanie zasobów w środowiskach baz danych ma kluczowy wpływ na wydajność i efektywność operacji obsługi danych. Kilka kluczowych zasobów, takich jak CPU, pamięć i operacje wejścia/wyjścia na dysku, wpływa na działanie bazy danych:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Użycie CPU: Procesor obsługuje wszystkie obliczenia związane z bazą danych, od wykonywania zapytań po zarządzanie transakcjami. Wysokie użycie procesora może wskazywać na nadmierne obciążenie bazy danych, co może prowadzić do spowolnienia operacji i długich czasów odpowiedzi. Maksymalne obciążenie procesora może również oznaczać, że zapytania nie są zoptymalizowane.

\item {} 
\sphinxAtStartPar
Wykorzystanie pamięci: Pamięć przechowuje aktywnie używane dane, a jej odpowiednia alokacja ma kluczowe znaczenie dla wydajności bazy danych. Wyczerpanie pamięci RAM i poleganie na pamięci dyskowej może znacząco obniżyć wydajność, co często wynika z wycieków pamięci lub niewłaściwych ustawień.

\item {} 
\sphinxAtStartPar
Operacje I/O na dysku: Operacje wejścia/wyjścia na dysku obejmują odczytywanie i zapisywanie danych, co ma istotne znaczenie dla przechowywania danych na dłuższy czas. Wysoki poziom operacji I/O na dysku może być objawem nieskutecznych strategii buforowania. Optymalne przechowywanie najczęściej używanych danych w pamięci może przyspieszyć operacje i uniknąć tworzenia wąskich gardeł związanym z dostępem do dysku.

\end{itemize}

\end{description}

\sphinxAtStartPar
Efektywne zarządzanie zasobami, takimi jak CPU, pamięć i operacje wejścia/wyjścia na dysku, jest kluczowe dla zapewnienia optymalnej wydajności bazy danych i uniknięcia spowolnień czy problemów z operacjami.


\section{5. Zapytania N+1}
\label{\detokenize{rozdzialy/rozdzial3:zapytania-n-1}}
\sphinxAtStartPar
Problemy z zapytaniami N+1 są powszechną nieefektywnością w aplikacjach korzystających z baz danych, szczególnie tych wykorzystujących narzędzia mapowania obiektowo\sphinxhyphen{}relacyjnego (ORM). Problem ten polega na nadmiernym wykonywaniu zapytań do bazy danych, co jest szczególnie zauważalne w przypadku, gdy aplikacja wykonuje dodatkowe zapytania dla każdego powiązanego obiektu po jednym początkowym zapytaniu. Przykładowo, jeśli aplikacja pobiera 10 użytkowników za pomocą jednego zapytania, a następnie wykonuje dodatkowe 10 zapytań dla pobrania profili każdego użytkownika, prowadzi to do łącznie 11 zapytań \sphinxhyphen{} co jest problemem zapytań N+1.
\begin{description}
\sphinxlineitem{Przyczyny problemów z zapytaniami N+1 to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Błędna konfiguracja ORM: Narzędzia ORM mają za zadanie ułatwić interakcję z bazą danych, ale nieprawidłowa konfiguracja może prowadzić do nieefektywnych strategii ładowania danych, takich jak „leniwe ładowanie”, które powoduje nadmiarowe zapytania.

\item {} 
\sphinxAtStartPar
Brak zapytań łączących: Niedostateczne wykorzystanie złączeń SQL może prowadzić do problemów z zapytaniami N+1, gdzie aplikacja pobiera dane fragmentarycznie zamiast łączyć je w jednym zapytaniu.

\item {} 
\sphinxAtStartPar
Niezoptymalizowane wzorce dostępu do danych: Nieefektywne praktyki kodowania, zwłaszcza te związane z iteracyjnym dostępem do danych, mogą prowadzić do nadmiernego wykonywania zapytań do bazy danych, szczególnie w przypadku pętli, które wyzwalają nowe zapytania dla każdej iteracji.

\end{itemize}

\end{description}

\sphinxAtStartPar
Rozwiązanie problemów z zapytaniami N+1 wymaga odpowiedniej konfiguracji ORM, wykorzystania złączeń SQL oraz optymalizacji wzorców dostępu do danych, aby uniknąć nadmiernego obciążenia bazą danych i poprawić wydajność aplikacji.


\section{6. Błędy bazy danych}
\label{\detokenize{rozdzialy/rozdzial3:bledy-bazy-danych}}\begin{description}
\sphinxlineitem{Wskaźniki wydajności bazy danych obejmują również błędy, które mogą wpływać na operacje na bazie danych, od pobierania danych po ich przechowywanie. Błędy te mogą objawiać się jako komunikaty o błędach lub kody, sygnalizujące konkretne problemy w systemie bazy danych. Typowe rodzaje błędów bazy danych to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Błędy połączenia: Pojawiają się, gdy aplikacja nie może nawiązać połączenia z bazą danych, co może być spowodowane problemami sieciowymi, błędami w ciągach połączeń lub awarią serwera bazy danych.

\item {} 
\sphinxAtStartPar
Błędy składni w zapytaniach: Występują, gdy polecenie SQL zawiera błędy składniowe, co powoduje odrzucenie go przez bazę danych, szczególnie w przypadku złożonych zapytań SQL.

\item {} 
\sphinxAtStartPar
Naruszenia ograniczeń: Bazy danych mają reguły, takie jak klucze obce i unikalne ograniczenia, które mają na celu utrzymanie integralności danych. Naruszenie tych ograniczeń, na przykład próba wstawienia duplikatu w miejscu, gdzie powinny być tylko unikalne wpisy, spowoduje zgłoszenie błędu przez bazę danych.

\item {} 
\sphinxAtStartPar
Błędy limitu zasobów: Pojawiają się, gdy baza danych przekracza limity dostępnych zasobów, takie jak brak miejsca na dysku, przeciążenie procesora czy brak pamięci. Te błędy mogą znacząco spowolnić lub nawet zatrzymać działanie systemu.

\item {} 
\sphinxAtStartPar
Błędy uprawnień i zabezpieczeń: Próba wykonania operacji bez odpowiednich uprawnień spowoduje błędy, na przykład brak dostępu do tabeli lub wykonywanie operacji bez wymaganych uprawnień.

\end{itemize}

\end{description}

\sphinxAtStartPar
Rozpoznanie i rozwiązanie tych błędów jest kluczowe dla zapewnienia stabilności i wydajności bazy danych oraz uniknięcia problemów podczas operacji na danych.

\sphinxstepscope


\chapter{Skalowanie}
\label{\detokenize{rozdzialy/rozdzial4:skalowanie}}\label{\detokenize{rozdzialy/rozdzial4::doc}}
\sphinxAtStartPar
Bazy danych SQL nie są tak kosztowne w rozbudowie, jak się powszechnie sądzi. Możliwe jest skalowanie ich wszerz, co przynosi wiele korzyści, zwłaszcza w kontekście analizy danych biznesowych. Firmy coraz bardziej interesują się analizą danych klientów pochodzących z różnych źródeł, co wymaga platform skalowalnych wszerz do przetwarzania dużych ilości danych w czasie rzeczywistym. Istnieje kilka opcji, takich jak bazy NoSQL, NewSQL czy platforma Hadoop, które mogą rozwiązać różne wyzwania związane z przetwarzaniem danych. Wdrożenie rozwiązania skalowalnego wszerz z odpowiednim balansem między pamięcią RAM a nośnikami flash może przynieść istotne korzyści, a nowa generacja skalowalnych baz SQL, takie jak InfiniSQL, ClustrixDB czy F1, pokazuje, że bazy SQL mogą być skalowalne wszerz.


\section{Analityka czasu rzeczywistego:}
\label{\detokenize{rozdzialy/rozdzial4:analityka-czasu-rzeczywistego}}
\sphinxAtStartPar
Analityka czasu rzeczywistego w branży Big Data skupia się obecnie na analizie danych w czasie rzeczywistym, co pozwala firmom uzyskać przewagę konkurencyjną i korzyści biznesowe. Istotnym elementem są skalowalne bazy danych SQL, które umożliwiają przetwarzanie danych operacyjnych w czasie rzeczywistym. Wykorzystanie metod przetwarzania kwerend w pamięci operacyjnej i macierzy dyskowych opartych na nośnikach SSD pozwala osiągnąć wysoką wydajność bez konieczności stosowania specjalistycznych rozwiązań. Firmy takie jak Google czy Facebook udowodniły, że bazy danych SQL są skutecznym narzędziem do przetwarzania danych, co może przyczynić się do ograniczenia kosztów zatrudniania specjalistów. Przykładowo, Google wykorzystuje bazę F1 SQL do usługi Adwords, co ułatwia tworzenie aplikacji do zadań OLTP i OLAP. Facebook również podkreśla znaczenie relacyjnych baz danych w analityce, co przekonało wielu do promowania rozszerzeń Hadoopa umożliwiających integrację z bazami SQL.


\section{Łatwa rozbudowa:}
\label{\detokenize{rozdzialy/rozdzial4:latwa-rozbudowa}}
\sphinxAtStartPar
Bazy danych SQL typu scale out umożliwiają łatwą liniową skalowalność poprzez dodawanie nowych węzłów do klastra, nawet w trakcie intensywnego użytkowania. Ta operacja nie wymaga zmian w kodzie, aktualizacji bazy danych ani wymiany sprzętu obsługującego aplikację. Każdy nowy węzeł może przyjmować i przetwarzać transakcje wraz z rozszerzaniem klastra. Istotną cechą tych baz SQL jest możliwość przenoszenia kodu bazy danych do węzłów przechowujących dane, zamiast przenoszenia samych danych. Dzięki temu ogranicza się ilość danych przesyłanych wewnątrz klastra, co prowadzi do zmniejszenia nadmiernego ruchu w klastrze i umożliwia liniową skalowalność bazy danych. Ponadto zapewnia to, że tylko jeden węzeł jest odpowiedzialny za zapis danych w określonym zbiorze, co eliminuje problem konkurencyjnego dostępu do tych samych zasobów. W tradycyjnych bazach danych każde zadanie blokuje obszary danych, co przy dużej liczbie zadań konkurencyjnych prowadzi do spadku wydajności.


\section{Eliminacja wąskich gardeł:}
\label{\detokenize{rozdzialy/rozdzial4:eliminacja-waskich-gardel}}
\sphinxAtStartPar
W skalowalnych bazach danych SQL rozwiązano problem logu transakcyjnego, który często stanowił wąskie gardło. W tradycyjnych bazach danych wszystkie przetwarzane rekordy są zapisywane w logu transakcyjnym przed zakończeniem kwerendy. W przypadku błędnej konfiguracji lub awarii może to spowodować nadmierny wzrost logu transakcyjnego, który może przekroczyć rozmiar samej bazy danych. To z kolei prowadzi do spowolnienia operacji zapisu w bazie, nawet w przypadku użycia nośników SSD.


\section{Wysoka dostępność w chmurze:}
\label{\detokenize{rozdzialy/rozdzial4:wysoka-dostepnosc-w-chmurze}}
\sphinxAtStartPar
Organizacje oczekują, że ich aplikacje produkcyjne będą zawsze dostępne, co zapewni ciągłość procesów biznesowych. W przypadku awarii chmury, która może się zdarzyć, istotne jest, aby firma mogła szybko przywrócić działanie bazy danych bez utraty danych. Skalowalne bazy danych SQL posiadają wbudowane funkcje wysokiej dostępności, które zapewniają przechowywanie kilku kopii danych, co minimalizuje ryzyko ich utraty.

\sphinxstepscope


\chapter{Replikacja}
\label{\detokenize{rozdzialy/rozdzial5:replikacja}}\label{\detokenize{rozdzialy/rozdzial5::doc}}
\sphinxAtStartPar
Replikacja danych to metoda duplikowania informacji pomiędzy różnymi serwerami baz danych.
Dzięki replikacji możemy:
\sphinxhyphen{} Zwiększyć skalowalność \textendash{} obciążenie można rozdzielić między wiele serwerów. Operacje takie jak zapisywanie i aktualizowanie rekordów są wykonywane na jednym serwerze, podczas gdy pobieranie i przeszukiwanie danych są realizowane na innym.
\sphinxhyphen{} Poprawić bezpieczeństwo \textendash{} poprzez replikację tworzymy kopię istniejącej bazy danych produkcyjnej. Choć nie zabezpieczy nas to przed operacjami typu DROP TABLE, może to być pomocne w przypadku awarii sprzętowej głównego serwera.
\sphinxhyphen{} Ułatwić analizę \textendash{} złożone operacje analityczne, różne przeliczenia i analizy statystyczne mogą być przeprowadzane na dedykowanym serwerze, bez obciążania głównej bazy danych.
\sphinxhyphen{} Zapewnić separację \textendash{} możemy udostępnić kopię bazy danych produkcyjnej dla programistów lub testerów, umożliwiając im pracę na kopii bazy.


\section{Mechanizmy replikacji}
\label{\detokenize{rozdzialy/rozdzial5:mechanizmy-replikacji}}
\sphinxAtStartPar
Replikacja w bazach danych odnosi się do procesu kopiowania i dystrybucji danych i obiektów z jednej bazy danych do innej, a następnie synchronizacji obu baz danych w celu utrzymania ich spójności.
Proces ten jest dość prosty. Główny serwer (master) prowadzi dziennik operacji, wykorzystując do tego pliki binarne zwane bin\sphinxhyphen{}logami, które zawierają instrukcje wykonane przez mastera. Te pliki są następnie odczytywane przez serwer zapasowy (slave), który wykonuje zapytania zawarte w bin\sphinxhyphen{}logach, co skutkuje dodawaniem nowych rekordów do bazy danych. W efekcie powstają dwie identyczne bazy danych. Po ustawieniu replikacji na serwerze master, uruchamiany jest dodatkowy wątek, który ma za zadanie wysyłać bin\sphinxhyphen{}logi do serwerów slave. Serwer zapasowy z kolei uruchamia dwa wątki: jeden do odczytu bin\sphinxhyphen{}logów i drugi do ich wykonania.
\sphinxhyphen{} Wątek I/O (Input/Output) \sphinxhyphen{} zajmuje się odbieraniem dziennika od serwera głównego i zapisywaniem go w plikach tymczasowych relay\sphinxhyphen{}log.
\sphinxhyphen{} Wątek SQL \sphinxhyphen{} parsuje te pliki i wykonuje zapytania do bazy danych.
W skrócie, mechanizm replikacji MySQL polega na tym, że serwer główny rejestruje swoje działania, a serwer zapasowy odtwarza te działania, tworząc kopię bazy danych.


\section{Oprogramowanie i zaimplementowane mechanizmy replikacji}
\label{\detokenize{rozdzialy/rozdzial5:oprogramowanie-i-zaimplementowane-mechanizmy-replikacji}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Replikacja oparta na zapisie (Write\sphinxhyphen{}Ahead Logging): Ten mechanizm jest powszechnie stosowany w systemach baz danych, takich jak PostgreSQL. Polega na rejestrowaniu transakcji w dzienniku zapisu przed ich zastosowaniem, a następnie replikacji dziennika na serwery repliki.

\item {} 
\sphinxAtStartPar
Replikacja oparta na zrzutach (Snapshot\sphinxhyphen{}Based Replication): Systemy, takie jak Apache Cassandra, wykorzystują replikację opartą na zrzutach. Polega to na tworzeniu zrzutów stanu bazy danych w określonych odstępach czasu i replikacji ich na serwery repliki.

\item {} 
\sphinxAtStartPar
Replikacja oparta na transakcjach (Transaction\sphinxhyphen{}Based Replication): W tym modelu każda transakcja jest replikowana na serwery repliki, co jest przydatne w systemach wymagających silnej spójności, np. Google Spanner.

\item {} 
\sphinxAtStartPar
Replikacja asynchroniczna i synchroniczna: W replikacji asynchronicznej dane są najpierw zapisywane do głównej bazy danych, a następnie replikowane na serwery repliki. W replikacji synchronicznej dane są zapisywane jednocześnie do głównej bazy danych i serwerów repliki.

\item {} 
\sphinxAtStartPar
Replikacja dwukierunkowa (Bi\sphinxhyphen{}Directional Replication): Pozwala na wprowadzanie zmian na dowolnym serwerze repliki, które są następnie replikowane na pozostałe serwery, co jest przydatne w przypadku wysokiej dostępności i tolerancji na awarie.

\end{itemize}

\sphinxAtStartPar
PostgreSQL oferuje różne typy replikacji, w tym replikację opartą na zapisie (Write\sphinxhyphen{}Ahead Logging), replikację asynchroniczną i synchroniczną oraz replikację logiczną. Replikacja oparta na zapisie (WAL) gwarantuje odporność na awarie poprzez zapisywanie zmian w bazie danych do dziennika zapisu przed ich zastosowaniem, który jest replikowany na serwery repliki. PostgreSQL obsługuje zarówno replikację asynchroniczną, gdzie dane są najpierw zapisywane do głównej bazy danych, a następnie replikowane, jak i replikację synchroniczną, gdzie dane są zapisywane jednocześnie do głównej bazy danych i serwerów repliki. Dodatkowo, replikacja logiczna pozwala na replikację wybranych tabel lub baz danych zamiast całego klastra, co jest przydatne zwłaszcza w przypadku dużych baz danych, gdzie replikacja całego klastra byłaby nieefektywna.


\section{Plusy i minusy replikacji}
\label{\detokenize{rozdzialy/rozdzial5:plusy-i-minusy-replikacji}}
\sphinxAtStartPar
Plusy:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Poprawa wydajności i dostępności: Replikacja danych pozwala na dystrybucję obciążenia zapytań pomiędzy wiele serwerów, co zwiększa wydajność systemu. Użytkownicy mogą wysyłać zapytania do najbliższego serwera repliki, co skraca czas odpowiedzi. Ponadto, jeśli jeden serwer ulegnie awarii, inne serwery repliki mogą nadal obsługiwać zapytania, co zwiększa dostępność systemu.

\item {} 
\sphinxAtStartPar
Bezpieczeństwo danych: Replikacja jest również kluczowym elementem strategii tworzenia kopii zapasowych i odzyskiwania danych. Jeśli główna baza danych ulegnie awarii, replika może zostać użyta do przywrócenia danych.

\item {} 
\sphinxAtStartPar
Dystrybucja danych: Replikacja umożliwia dystrybucję danych do oddzielnych lokalizacji geograficznych. Na przykład, globalna firma może chcieć replikować dane między swoimi lokalizacjami w różnych krajach, aby lokalni użytkownicy mogli szybko i łatwo uzyskać dostęp do potrzebnych informacji.

\item {} 
\sphinxAtStartPar
Analiza i raportowanie: Repliki danych mogą być używane do celów analitycznych i raportowych. Dzięki temu operacje te nie wpływają na wydajność głównej bazy danych obsługującej transakcje.

\end{itemize}

\sphinxAtStartPar
Minusy:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Nie daje nam pewności, że po przeprowadzeniu operacji, dane z serwera głównego będą poprawnie przeniesione na serwer zapasowy

\item {} 
\sphinxAtStartPar
Nie zapewnia ochrony przed operacjami niosącymi poważne konsekwencje \sphinxhyphen{} takimi jak DROP TABLE

\end{itemize}

\sphinxstepscope


\chapter{Limity systemu oraz ograniczanie dostępu użytkowników}
\label{\detokenize{rozdzialy/rozdzial6:limity-systemu-oraz-ograniczanie-dostepu-uzytkownikow}}\label{\detokenize{rozdzialy/rozdzial6::doc}}
\sphinxAtStartPar
Limity systemu w zarządzaniu bazami danych odnoszą się do maksymalnej liczby zasobów, które system może obsłużyć. Te limity są zwykle określane przez system zarządzania bazą danych (DBMS) i są zdefiniowane na podstawie dostępnych zasobów sprzętowych i ustawień konfiguracyjnych. Na przykład, w Azure SQL Database istnieją specyficzne limity zasobów dla różnych poziomów cenowych dla pojedynczych baz danych. W MySQL, efektywny maksymalny rozmiar tabeli dla baz danych MySQL jest zazwyczaj określany przez ograniczenia systemu operacyjnego na rozmiary plików, a nie przez wewnętrzne limity MySQL.
Ograniczanie dostępu użytkowników w DBMS odnosi się do mechanizmu, który umożliwia lub zabrania użytkownikom dostęp do danych. Składa się z dwóch głównych komponentów: uwierzytelniania i autoryzacji. Uwierzytelnianie to sposób potwierdzenia tożsamości osoby, która próbuje uzyskać dostęp do bazy danych. Autoryzacja natomiast określa, czy poziom dostępu użytkownika jest odpowiedni. Istnieją różne modele kontroli dostępu, takie jak Kontrola Dostępu Uzależniona (DAC), Kontrola Dostępu Obowiązkowa (MAC), Kontrola Dostępu na Podstawie Roli (RBAC) i Kontrola Dostępu na Podstawie Atrybutów (ABAC).
W PostgreSQL również istnieją mechanizmy do zarządzania limitami systemu oraz ograniczania dostępu użytkowników. PostgreSQL umożliwia administratorom określenie różnych parametrów konfiguracyjnych, takich jak maksymalna ilość połączeń, pamięć dostępna dla zapytań, maksymalny rozmiar pliku danych, czy maksymalny rozmiar tabeli. Te limity mogą być dostosowywane do potrzeb konkretnego środowiska i obciążenia.
W kwestii ograniczania dostępu użytkowników, PostgreSQL oferuje zaawansowane mechanizmy uwierzytelniania i autoryzacji. Można definiować różne role użytkowników, nadawać im odpowiednie uprawnienia do baz danych, schematów, tabel czy nawet poszczególnych kolumn. PostgreSQL obsługuje zarówno uwierzytelnianie oparte na hasłach, jak i uwierzytelnianie oparte na certyfikatach SSL.
Dzięki tym funkcjom, administratorzy baz danych mogą skutecznie kontrolować dostęp do danych, zapewniając bezpieczeństwo i poufność informacji przechowywanych w PostgreSQL.

\sphinxstepscope


\chapter{Testy wydajności sprzętu (pamięć, procesor, dyski) na poziomie systemu operacyjnego}
\label{\detokenize{rozdzialy/rozdzial7:testy-wydajnosci-sprzetu-pamiec-procesor-dyski-na-poziomie-systemu-operacyjnego}}\label{\detokenize{rozdzialy/rozdzial7::doc}}
\sphinxAtStartPar
Testy wydajności sprzętu na poziomie systemu operacyjnego są kluczowe dla optymalizacji wydajności baz danych. Obejmują one testy pamięci (RAM), procesora (CPU) oraz dysków (HDD/SSD), które są kluczowymi komponentami sprzętowymi wpływającymi na wydajność systemu.

\sphinxAtStartPar
Testy pamięci (RAM) oceniają szybkość i efektywność pamięci RAM komputera, co ma bezpośredni wpływ na wydajność bazy danych. Narzędzia takie jak MemTest86 mogą być używane do przeprowadzania tych testów.

\sphinxAtStartPar
Testy procesora (CPU) oceniają wydajność jednostki centralnej procesora, która jest kluczowa dla szybkości przetwarzania zapytań do bazy danych. Narzędzia takie jak Cinebench R23 mogą być używane do przeprowadzania tych testów.

\sphinxAtStartPar
Testy dysków (HDD/SSD) oceniają szybkość odczytu i zapisu na dyskach, co ma istotne znaczenie dla wydajności bazy danych, ponieważ dane są przechowywane na dyskach. Narzędzia takie jak CrystalDiskMark 8 i Acronis Drive Monitor mogą być używane do przeprowadzania tych testów.

\sphinxAtStartPar
Wyniki tych testów na poziomie systemu operacyjnego mogą pomóc zidentyfikować obszary, które wymagają ulepszeń sprzętowych, aby zwiększyć wydajność bazy danych, niezależnie od konkretnego oprogramowania bazy danych.

\sphinxstepscope


\chapter{pg\_hba.conf \sphinxhyphen{} Sterowanie Dostępem}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial1:pg-hba-conf-sterowanie-dostepem}}\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial1::doc}}
\sphinxAtStartPar
Plik \sphinxcode{\sphinxupquote{pg\_hba.conf}} (PostgreSQL Host\sphinxhyphen{}Based Authentication) jest
kluczowym elementem zarządzania bezpieczeństwem w PostgreSQL. Umożliwia
on kontrolę dostępu do serwera bazy danych na podstawie adresów IP,
typów połączeń oraz mechanizmów uwierzytelniania.


\section{Struktura pliku pg\_hba.conf}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial1:struktura-pliku-pg-hba-conf}}
\sphinxAtStartPar
Plik \sphinxcode{\sphinxupquote{pg\_hba.conf}} składa się z linii, z których każda definiuje
regułę dostępu. Każda linia zawiera następujące pola:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{typ połączenia} \sphinxhyphen{} określa, czy połączenie jest lokalne
(\sphinxcode{\sphinxupquote{local}}), czy zdalne (\sphinxcode{\sphinxupquote{host}}).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{baza danych} \sphinxhyphen{} nazwa bazy danych, do której dostęp jest
kontrolowany.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{użytkownik} \sphinxhyphen{} nazwa użytkownika bazy danych.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{adres} \sphinxhyphen{} adres IP klienta (dla połączeń zdalnych).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{metoda uwierzytelniania} \sphinxhyphen{} określa mechanizm uwierzytelniania,
który ma być używany.

\end{itemize}

\sphinxAtStartPar
Przykład reguły w pliku \sphinxcode{\sphinxupquote{pg\_hba.conf}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Typ    Baza danych    Użytkownik    Adres              Metoda}
\PYG{n}{host}     \PYG{n+nb}{all}            \PYG{n+nb}{all}           \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.1}\PYG{l+m+mf}{.0}\PYG{o}{/}\PYG{l+m+mi}{24}     \PYG{n}{md5}
\end{sphinxVerbatim}


\section{Mechanizmy Dostępu}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial1:mechanizmy-dostepu}}
\sphinxAtStartPar
Plik \sphinxcode{\sphinxupquote{pg\_hba.conf}} definiuje kilka mechanizmów uwierzytelniania,
takich jak:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{trust} \sphinxhyphen{} pozwala na dostęp bez uwierzytelniania. Jest to opcja
najmniej bezpieczna i powinna być używana tylko w wyjątkowych
przypadkach.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{md5} \sphinxhyphen{} wykorzystuje hasła zaszyfrowane algorytmem MD5. Jest to
standardowy mechanizm uwierzytelniania.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{password} \sphinxhyphen{} wymaga podania hasła w postaci nieszyfrowanej. Jest to
mniej bezpieczne niż \sphinxcode{\sphinxupquote{md5}}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{peer} \sphinxhyphen{} umożliwia uwierzytelnianie na podstawie identyfikatora
systemowego użytkownika.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{cert} \sphinxhyphen{} wykorzystuje certyfikaty SSL do uwierzytelniania.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scram\sphinxhyphen{}sha\sphinxhyphen{}256} \sphinxhyphen{} nowoczesny i bezpieczny mechanizm
uwierzytelniania, który wykorzystuje algorytm SCRAM\sphinxhyphen{}SHA\sphinxhyphen{}256.

\end{itemize}


\section{Konsekwencje Wyboru Mechanizmu Dostępu}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial1:konsekwencje-wyboru-mechanizmu-dostepu}}
\sphinxAtStartPar
Wybór odpowiedniego mechanizmu uwierzytelniania ma bezpośredni wpływ na
bezpieczeństwo systemu. Mechanizmy takie jak \sphinxcode{\sphinxupquote{trust}} mogą znacznie
obniżyć poziom bezpieczeństwa, podczas gdy \sphinxcode{\sphinxupquote{cert}} w połączeniu z SSL
zapewnia wysoki poziom ochrony danych. Warto dokładnie analizować
potrzeby i ryzyka związane z każdym mechanizmem uwierzytelniania.

\sphinxAtStartPar
Na przykład, stosowanie mechanizmu \sphinxcode{\sphinxupquote{trust}} może być akceptowalne w
przypadku baz danych używanych wyłącznie w środowisku testowym, gdzie
bezpieczeństwo nie jest priorytetem. Natomiast w środowisku
produkcyjnym, gdzie przetwarzane są dane wrażliwe, konieczne jest użycie
bardziej zaawansowanych mechanizmów, takich jak \sphinxcode{\sphinxupquote{md5}},
\sphinxcode{\sphinxupquote{scram\sphinxhyphen{}sha\sphinxhyphen{}256}} lub \sphinxcode{\sphinxupquote{cert}}.


\section{Przykłady Konfiguracji}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial1:przyklady-konfiguracji}}
\sphinxAtStartPar
Przykładowe konfiguracje pliku \sphinxcode{\sphinxupquote{pg\_hba.conf}} mogą obejmować różne
scenariusze dostępu:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Pozwól} \PYG{n}{na} \PYG{n}{połączenie} \PYG{n}{dowolnego} \PYG{n}{użytkownika} \PYG{n}{z} \PYG{n}{hostem} \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.12}\PYG{l+m+mf}{.10} \PYG{n}{do} \PYG{n}{bazy} \PYG{n}{danych} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{postgres}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{jeśli} \PYG{n}{hasło}
\PYG{n}{użytkownika} \PYG{n}{jest} \PYG{n}{poprawnie} \PYG{n}{podane}
\PYG{c+c1}{\PYGZsh{} Typ   Baza danych    Użytkownik    Adres              Metoda}
\PYG{n}{host}    \PYG{n}{postgres}       \PYG{n+nb}{all}           \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.12}\PYG{l+m+mf}{.10}\PYG{o}{/}\PYG{l+m+mi}{32}   \PYG{n}{scram}\PYG{o}{\PYGZhy{}}\PYG{n}{sha}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{256}

\PYG{n}{Pozwól} \PYG{n}{dowolnemu} \PYG{n}{użytkownikowi} \PYG{n}{na} \PYG{n}{lokalnym} \PYG{n}{systemie} \PYG{n}{łączyć} \PYG{n}{się} \PYG{n}{z} \PYG{n}{dowolną} \PYG{n}{bazą} \PYG{n}{danych}
\PYG{n}{używając} \PYG{n}{dowolnej} \PYG{n}{nazwy} \PYG{n}{użytkownika} \PYG{n}{bazy} \PYG{n}{danych} \PYG{n}{za} \PYG{n}{pomocą} \PYG{n}{gniazd} \PYG{n}{Unix} \PYG{p}{(}\PYG{n}{domyślnie} \PYG{n}{dla} \PYG{n}{połączeń} \PYG{n}{lokalnych}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Typ   Baza danych    Użytkownik    Adres              Metoda}
\PYG{n}{local}   \PYG{n+nb}{all}            \PYG{n+nb}{all}                              \PYG{n}{trust}

\PYG{n}{Pozwól} \PYG{n}{na} \PYG{n}{połączenie} \PYG{n}{używając} \PYG{n}{wyrażenia} \PYG{n}{regularnego} \PYG{n}{dla} \PYG{n}{DATABASE}\PYG{p}{,} \PYG{n}{które} \PYG{n}{pozwala} \PYG{n}{na} \PYG{n}{połączenie} \PYG{n}{z} \PYG{n}{bazą} \PYG{n}{danych} \PYG{n}{db1}\PYG{p}{,} \PYG{n}{db2}
\PYG{n}{oraz} \PYG{n}{dowolnymi} \PYG{n}{bazami} \PYG{n}{danych} \PYG{n}{o} \PYG{n}{nazwie} \PYG{n}{zaczynającej} \PYG{n}{się} \PYG{n}{od} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{db}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{i} \PYG{n}{kończącej} \PYG{n}{się} \PYG{n}{liczbą} \PYG{n}{składającą} \PYG{n}{się} \PYG{n}{z} \PYG{n}{dwóch} \PYG{n}{do}
\PYG{n}{czterech} \PYG{n}{cyfr} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{db1234}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lub} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{db12}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}
\PYG{c+c1}{\PYGZsh{} Typ   Baza danych                Użytkownik    Adres          Metoda}
\PYG{n}{local}   \PYG{n}{db1}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/\PYGZca{}db}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{2,4\PYGZcb{}\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{db2}     \PYG{n+nb}{all}           \PYG{n}{localhost}      \PYG{n}{trust}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Uprawnienia Użytkownika}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial2:uprawnienia-uzytkownika}}\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial2::doc}}
\sphinxAtStartPar
Uprawnienia użytkownika w PostgreSQL są zarządzane na kilku poziomach:
systemu zarządzania bazą danych (DBMS), poszczególnych baz danych oraz
tabel.


\section{Poziom DBMS}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial2:poziom-dbms}}
\sphinxAtStartPar
Na poziomie DBMS uprawnienia mogą obejmować możliwość tworzenia nowych
baz danych, zarządzanie użytkownikami oraz konfigurację systemu.
Przykładowe polecenia to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GRANT} \PYG{n}{CREATE} \PYG{n}{ON} \PYG{n}{DATABASE} \PYG{n}{dbname} \PYG{n}{TO} \PYG{n}{username}\PYG{p}{;}
\PYG{n}{REVOKE} \PYG{n}{CREATE} \PYG{n}{ON} \PYG{n}{DATABASE} \PYG{n}{dbname} \PYG{n}{FROM} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Administratorzy bazy danych (DBA) mają pełne uprawnienia na poziomie
DBMS, co pozwala im na zarządzanie wszystkimi aspektami działania
systemu PostgreSQL. Uprawnienia te mogą obejmować:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tworzenie i usuwanie baz danych.

\item {} 
\sphinxAtStartPar
Tworzenie i zarządzanie użytkownikami oraz rolami.

\item {} 
\sphinxAtStartPar
Konfigurację parametrów systemowych i optymalizację działania bazy
danych.

\end{itemize}


\section{Poziom Bazy Danych}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial2:poziom-bazy-danych}}
\sphinxAtStartPar
Na poziomie bazy danych uprawnienia mogą obejmować dostęp do danych,
modyfikację struktur oraz wykonywanie operacji administracyjnych.
Polecenia zarządzające uprawnieniami to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GRANT} \PYG{n}{ALL} \PYG{n}{PRIVILEGES} \PYG{n}{ON} \PYG{n}{DATABASE} \PYG{n}{dbname} \PYG{n}{TO} \PYG{n}{username}\PYG{p}{;}
\PYG{n}{REVOKE} \PYG{n}{CONNECT} \PYG{n}{ON} \PYG{n}{DATABASE} \PYG{n}{dbname} \PYG{n}{FROM} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Uprawnienia na poziomie bazy danych mogą być szczegółowo dostosowane do
potrzeb poszczególnych użytkowników lub grup użytkowników (ról). Na
przykład, można przyznać uprawnienia do:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Łączenia się z bazą danych (\sphinxcode{\sphinxupquote{CONNECT}}).

\item {} 
\sphinxAtStartPar
Tworzenia nowych schematów (\sphinxcode{\sphinxupquote{CREATE}}).

\item {} 
\sphinxAtStartPar
Wykonywania zapytań (\sphinxcode{\sphinxupquote{SELECT}}) i modyfikacji danych (\sphinxcode{\sphinxupquote{INSERT}},
\sphinxcode{\sphinxupquote{UPDATE}}, \sphinxcode{\sphinxupquote{DELETE}}).

\item {} 
\sphinxAtStartPar
Zarządzania tabelami i innymi obiektami bazy danych (\sphinxcode{\sphinxupquote{ALTER}},
\sphinxcode{\sphinxupquote{DROP}}).

\end{itemize}


\section{Poziom Tabeli}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial2:poziom-tabeli}}
\sphinxAtStartPar
Na poziomie tabeli uprawnienia mogą obejmować selekcję, wstawianie,
aktualizację oraz usuwanie danych. Przykładowe polecenia to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GRANT} \PYG{n}{SELECT}\PYG{p}{,} \PYG{n}{INSERT} \PYG{n}{ON} \PYG{n}{TABLE} \PYG{n}{tablename} \PYG{n}{TO} \PYG{n}{username}\PYG{p}{;}
\PYG{n}{REVOKE} \PYG{n}{UPDATE} \PYG{n}{ON} \PYG{n}{TABLE} \PYG{n}{tablename} \PYG{n}{FROM} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Precyzyjne zarządzanie uprawnieniami na poziomie tabeli pozwala na
ochronę danych przed nieautoryzowanym dostępem oraz modyfikacją.
Przykłady uprawnień obejmują:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SELECT}} \sphinxhyphen{} możliwość odczytu danych z tabeli.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{INSERT}} \sphinxhyphen{} możliwość dodawania nowych rekordów do tabeli.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UPDATE}} \sphinxhyphen{} możliwość modyfikowania istniejących rekordów.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DELETE}} \sphinxhyphen{} możliwość usuwania rekordów.

\end{itemize}


\section{Role i Grupy Użytkowników}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial2:role-i-grupy-uzytkownikow}}
\sphinxAtStartPar
PostgreSQL umożliwia tworzenie ról i grup użytkowników, co upraszcza
zarządzanie uprawnieniami. Role mogą mieć przypisane uprawnienia, które
są dziedziczone przez użytkowników przypisanych do tych ról. Przykładowe
polecenia:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CREATE} \PYG{n}{ROLE} \PYG{n}{read\PYGZus{}only}\PYG{p}{;}
\PYG{n}{GRANT} \PYG{n}{SELECT} \PYG{n}{ON} \PYG{n}{ALL} \PYG{n}{TABLES} \PYG{n}{IN} \PYG{n}{SCHEMA} \PYG{n}{public} \PYG{n}{TO} \PYG{n}{read\PYGZus{}only}\PYG{p}{;}
\PYG{n}{GRANT} \PYG{n}{read\PYGZus{}only} \PYG{n}{TO} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Stosowanie ról i grup użytkowników pozwala na bardziej elastyczne i
skalowalne zarządzanie uprawnieniami. Na przykład, można stworzyć rolę
\sphinxcode{\sphinxupquote{read\_only}}, która ma tylko uprawnienia do odczytu danych, a następnie
przypisać tę rolę wielu użytkownikom, co znacznie upraszcza
administrację.

\sphinxstepscope


\chapter{Zarządzanie Użytkownikami a Dane Wprowadzone}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial3:zarzadzanie-uzytkownikami-a-dane-wprowadzone}}\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial3::doc}}
\sphinxAtStartPar
Zarządzanie użytkownikami w PostgreSQL obejmuje tworzenie, modyfikowanie
i usuwanie użytkowników oraz ról. Ważnym aspektem jest zarządzanie
danymi wprowadzonymi przez użytkowników, szczególnie w kontekście
usuwania użytkowników.


\section{Tworzenie i Modyfikowanie Użytkowników}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial3:tworzenie-i-modyfikowanie-uzytkownikow}}
\sphinxAtStartPar
Tworzenie nowych użytkowników w PostgreSQL odbywa się za pomocą
polecenia \sphinxcode{\sphinxupquote{CREATE USER}}. Przykład:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CREATE} \PYG{n}{USER} \PYG{n}{username} \PYG{n}{WITH} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{password}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Modyfikowanie istniejących użytkowników można przeprowadzać za pomocą
polecenia \sphinxcode{\sphinxupquote{ALTER USER}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ALTER} \PYG{n}{USER} \PYG{n}{username} \PYG{n}{WITH} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZus{}password}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Usuwanie Użytkowników}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial3:usuwanie-uzytkownikow}}
\sphinxAtStartPar
Usuwanie użytkowników w PostgreSQL odbywa się za pomocą polecenia
\sphinxcode{\sphinxupquote{DROP USER}}. Przykład:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DROP} \PYG{n}{USER} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Jednakże usunięcie użytkownika nie powoduje automatycznego usunięcia
danych, które zostały przez niego wprowadzone. Dane te pozostają w bazie
danych i mogą być dalej dostępne dla innych użytkowników z odpowiednimi
uprawnieniami.


\section{Zachowanie Danych po Usunięciu Użytkownika}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial3:zachowanie-danych-po-usunieciu-uzytkownika}}
\sphinxAtStartPar
Dane wprowadzone przez usuniętego użytkownika pozostają w bazie danych,
co jest ważne dla zapewnienia integralności i ciągłości danych. W
praktyce oznacza to, że:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Rekordy w tabelach nadal istnieją i są dostępne dla innych
użytkowników z odpowiednimi uprawnieniami.

\item {} 
\sphinxAtStartPar
Metadane, takie jak informacje o autorze danych, mogą być zachowane w
celach audytowych.

\end{itemize}

\sphinxAtStartPar
Przykłady scenariuszy, w których zachowanie danych po usunięciu
użytkownika jest istotne:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Zmiany kadrowe} \sphinxhyphen{} gdy pracownik odchodzi z firmy, jego dane
powinny pozostać w systemie.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Reorganizacja projektów} \sphinxhyphen{} dane wprowadzone przez użytkownika mogą
być ważne dla trwających projektów.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Naruszenia bezpieczeństwa} \sphinxhyphen{} w przypadku konieczności szybkiego
usunięcia użytkownika, dane pozostają nienaruszone.

\end{itemize}


\section{Polityki Retencji Danych}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial3:polityki-retencji-danych}}
\sphinxAtStartPar
Organizacje mogą wdrażać polityki retencji danych, które określają, jak
długo dane wprowadzone przez użytkowników są przechowywane oraz w jakich
warunkach mogą być usuwane. Polityki te mogą obejmować:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Automatyczne usuwanie danych po określonym czasie.

\item {} 
\sphinxAtStartPar
Przeglądy i audyty danych w celu określenia ich dalszej przydatności.

\item {} 
\sphinxAtStartPar
Mechanizmy archiwizacji danych w celu ich późniejszego odzyskania,
jeśli zajdzie taka potrzeba.

\end{itemize}

\sphinxstepscope


\chapter{Zabezpieczenie Połączenia przez SSL/TLS}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial4:zabezpieczenie-polaczenia-przez-ssl-tls}}\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial4::doc}}
\sphinxAtStartPar
SSL (Secure Sockets Layer) oraz TLS (Transport Layer Security) są
standardowymi technologiami zabezpieczającymi połączenia sieciowe, w tym
również połączenia z bazą danych PostgreSQL.


\section{Konfiguracja SSL/TLS}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial4:konfiguracja-ssl-tls}}
\sphinxAtStartPar
Aby włączyć SSL/TLS w PostgreSQL, należy skonfigurować plik
\sphinxcode{\sphinxupquote{postgresql.conf}} oraz odpowiednio dostosować plik \sphinxcode{\sphinxupquote{pg\_hba.conf}}.
Przykład konfiguracji:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} postgresql.conf}
\PYG{n}{ssl} \PYG{o}{=} \PYG{n}{on}
\PYG{n}{ssl\PYGZus{}cert\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{server.crt}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ssl\PYGZus{}key\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{server.key}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Dodatkowo, w pliku \sphinxcode{\sphinxupquote{pg\_hba.conf}} należy zdefiniować reguły
uwierzytelniania z użyciem certyfikatów SSL:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} pg\PYGZus{}hba.conf}
\PYG{n}{hostssl} \PYG{n+nb}{all} \PYG{n+nb}{all} \PYG{l+m+mf}{0.0}\PYG{l+m+mf}{.0}\PYG{l+m+mf}{.0}\PYG{o}{/}\PYG{l+m+mi}{0} \PYG{n}{cert}
\end{sphinxVerbatim}


\section{Tworzenie i Zarządzanie Certyfikatami}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial4:tworzenie-i-zarzadzanie-certyfikatami}}
\sphinxAtStartPar
Do korzystania z SSL/TLS konieczne jest posiadanie certyfikatu serwera
oraz klucza prywatnego. Certyfikaty te mogą być wydawane przez zaufane
urzędy certyfikacji (CA) lub generowane samodzielnie (self\sphinxhyphen{}signed).
Przykładowe polecenia do generowania własnych certyfikatów:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{genrsa} \PYG{o}{\PYGZhy{}}\PYG{n}{des3} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{l+m+mi}{2048}
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{csr}
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{days} \PYG{l+m+mi}{365} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{server}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{signkey} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}
\end{sphinxVerbatim}


\section{Korzyści z SSL/TLS}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial4:korzysci-z-ssl-tls}}
\sphinxAtStartPar
SSL/TLS zapewnia szyfrowanie danych przesyłanych między klientem a
serwerem, co chroni przed podsłuchiwaniem oraz modyfikowaniem danych
podczas transmisji. Zapewnia również uwierzytelnienie serwera oraz,
opcjonalnie, klienta, co zwiększa bezpieczeństwo całego systemu.

\sphinxAtStartPar
Korzyści z używania SSL/TLS obejmują:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ochronę danych wrażliwych podczas transmisji przez sieć.

\item {} 
\sphinxAtStartPar
Zapobieganie atakom typu man\sphinxhyphen{}in\sphinxhyphen{}the\sphinxhyphen{}middle, które polegają na
przechwytywaniu i modyfikacji danych.

\item {} 
\sphinxAtStartPar
Uwierzytelnianie serwera, co pozwala klientom na weryfikację, że
łączą się z właściwym serwerem.

\end{itemize}


\section{Monitorowanie i Audyt Połączeń SSL/TLS}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial4:monitorowanie-i-audyt-polaczen-ssl-tls}}
\sphinxAtStartPar
Ważnym aspektem korzystania z SSL/TLS jest monitorowanie i audyt
połączeń zabezpieczonych. PostgreSQL oferuje mechanizmy logowania, które
mogą rejestrować informacje o połączeniach SSL/TLS, co pozwala na:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identyfikację prób nieautoryzowanego dostępu.

\item {} 
\sphinxAtStartPar
Analizę i diagnostykę problemów z połączeniami.

\item {} 
\sphinxAtStartPar
Zapewnienie zgodności z politykami bezpieczeństwa organizacji.

\end{itemize}

\sphinxstepscope


\chapter{Szyfrowanie Danych}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial5:szyfrowanie-danych}}\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial5::doc}}
\sphinxAtStartPar
Szyfrowanie danych w PostgreSQL może odbywać się zarówno na poziomie
transmisji danych, jak i na poziomie przechowywania danych.


\section{Szyfrowanie w Transmisji}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial5:szyfrowanie-w-transmisji}}
\sphinxAtStartPar
Jak wspomniano wcześniej, SSL/TLS umożliwia szyfrowanie danych podczas
transmisji między klientem a serwerem, co zapobiega nieautoryzowanemu
dostępowi do danych w trakcie ich przesyłania.


\section{Szyfrowanie na Poziomie Dysku}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial5:szyfrowanie-na-poziomie-dysku}}
\sphinxAtStartPar
PostgreSQL nie posiada natywnego wsparcia dla szyfrowania danych na
poziomie tabel lub baz danych, jednak możliwe jest wykorzystanie
zewnętrznych narzędzi i systemów plików szyfrujących. Przykładem może
być system plików z szyfrowaniem (np. LUKS w systemach Linux) lub
szyfrowanie oferowane przez rozwiązania chmurowe (np. Amazon RDS).

\sphinxAtStartPar
Przykładowa konfiguracja szyfrowania dysku na systemie Linux z użyciem
LUKS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{cryptsetup} \PYG{n}{luksFormat} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{sdX}
\PYG{n}{sudo} \PYG{n}{cryptsetup} \PYG{n}{luksOpen} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{sdX} \PYG{n}{encrypted\PYGZus{}disk}
\PYG{n}{sudo} \PYG{n}{mkfs}\PYG{o}{.}\PYG{n}{ext4} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{mapper}\PYG{o}{/}\PYG{n}{encrypted\PYGZus{}disk}
\PYG{n}{sudo} \PYG{n}{mount} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{mapper}\PYG{o}{/}\PYG{n}{encrypted\PYGZus{}disk} \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{encrypted}
\end{sphinxVerbatim}


\section{Szyfrowanie na Poziomie Aplikacji}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial5:szyfrowanie-na-poziomie-aplikacji}}
\sphinxAtStartPar
Innym podejściem do szyfrowania danych jest szyfrowanie na poziomie
aplikacji, gdzie dane są szyfrowane przed zapisaniem do bazy danych i
odszyfrowywane po ich odczytaniu. Takie podejście zapewnia pełną
kontrolę nad procesem szyfrowania, jednak wymaga dodatkowej
implementacji w kodzie aplikacji.

\sphinxAtStartPar
Przykładowe biblioteki do szyfrowania danych na poziomie aplikacji:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Python} \sphinxhyphen{} \sphinxcode{\sphinxupquote{cryptography}}, \sphinxcode{\sphinxupquote{pycryptodome}}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Java} \sphinxhyphen{} \sphinxcode{\sphinxupquote{javax.crypto}}, \sphinxcode{\sphinxupquote{Bouncy Castle}}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{JavaScript} \sphinxhyphen{} \sphinxcode{\sphinxupquote{crypto}}, \sphinxcode{\sphinxupquote{sjcl}}.

\end{itemize}


\section{Zarządzanie Kluczami Szyfrującymi}
\label{\detokenize{sprawozdanie/source/rozdzialy/rozdzial5:zarzadzanie-kluczami-szyfrujacymi}}
\sphinxAtStartPar
Kluczowym elementem skutecznego szyfrowania danych jest zarządzanie
kluczami szyfrującymi. Klucze muszą być bezpiecznie przechowywane i
zarządzane, aby zapobiec ich utracie lub kradzieży. Przykładowe
narzędzia do zarządzania kluczami:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{HashiCorp Vault} \sphinxhyphen{} bezpieczne przechowywanie i zarządzanie
tajemnicami oraz kluczami szyfrującymi.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{AWS Key Management Service (KMS)} \sphinxhyphen{} zarządzanie kluczami w
środowisku chmurowym Amazon Web Services.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GCP Cloud KMS} \sphinxhyphen{} zarządzanie kluczami w środowisku Google Cloud
Platform.

\end{itemize}

\sphinxAtStartPar
..Indices and tables
..==================

\sphinxAtStartPar
..* \DUrole{xref,std,std-ref}{genindex}
..* \DUrole{xref,std,std-ref}{modindex}
..* \DUrole{xref,std,std-ref}{search}



\renewcommand{\indexname}{Indeks}
\printindex
\end{document}